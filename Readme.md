# Transaction Workflow Engine â€” Home Assignment

> **3 approaches** to the same backend assignment, each demonstrating a different level of architectural maturity using a reusable skill set adapted from my previous implementations.

---

## ğŸ“‚ Repository Structure

```text
sqlink-task/
â”œâ”€â”€ TransactionWorkflow_ApproachA.zip    # Vanilla .NET Clean Architecture
â”œâ”€â”€ TransactionWorkflow_ApproachB.zip    # DNA-Infused Multi-Tenant Engine
â”œâ”€â”€ TransactionWorkflow_ApproachD.zip    # Strategic Hybrid
â”œâ”€â”€ buildAll.ps1                         # One-click extract + build all 3
â”œâ”€â”€ testAll.ps1                          # Full integration test suite v2 (45 tests across 3 approaches)
â”œâ”€â”€ Backend_Home_Assignment.docx         # Original assignment brief
â”œâ”€â”€ Readme.md                            # â† You are here
â”‚
â”œâ”€â”€ CodeDocumentation.docx               # Directory scheme + layer-by-layer code documentation
â”œâ”€â”€ ApproachComparison.docx              # Architectural differences + decision matrix
â”œâ”€â”€ BugInvestigation_SKILL.md            # EF Core tracking conflict debugging methodology
â”‚
â”œâ”€â”€ approach_analysis.md                 # Deep analysis of all 4 approaches (A, B, C, D)
â”œâ”€â”€ approach_analysis.jsx                # Interactive React comparison UI
â”œâ”€â”€ approaches_comparison.md             # Side-by-side flow comparison (A vs B vs D)
â”œâ”€â”€ cto_analysis.jsx                     # Interactive architectural decision dashboard
â”‚
â”œâ”€â”€ FINAL_STATE.md                       # Phase 1â€“11 completion tracking (V2)
â””â”€â”€ TEST_REPORT.md                       # Auto-generated by testAll.ps1 (45 tests)
```

---

## ğŸš€ Quick Start â€” Build & Run All 3

### Prerequisites
- .NET 8 SDK
- Docker & Docker Compose (for running)
- PowerShell (for `buildAll.ps1`)

### One Command
```powershell
.\buildAll.ps1
```

This script extracts all 3 zips, applies known patches, and builds each solution. After build succeeds, run any approach:

```bash
cd TransactionWorkflow_ApproachD     # or A, or B
./start.sh                            # Linux / Mac / WSL
# â€” or â€”
docker-compose up --build -d          # Windows native
# â†’ Swagger UI: http://localhost:5000/swagger
# â†’ Health Check: http://localhost:5000/health
```

### Run Tests
```bash
# Unit tests (no Docker required)
cd TransactionWorkflow_ApproachD
dotnet test

# Full integration tests â€” all 3 approaches via Docker (from root)
.\testAll.ps1
```

> **âš ï¸ PowerShell Execution Policy Error?** If you see `cannot be loaded... is not digitally signed`, run with bypass:
> ```powershell
> powershell -ExecutionPolicy Bypass -File .\testAll.ps1
> powershell -ExecutionPolicy Bypass -File .\buildAll.ps1
> ```
> Or set it permanently for your user:
> ```powershell
> Set-ExecutionPolicy -Scope CurrentUser -ExecutionPolicy RemoteSigned
> ```

---

## ğŸ—ï¸ The 3 Approaches

### Approach A â€” "Textbook Clean Architecture" (Vanilla)

The safe, expected solution. Classical .NET Clean Architecture with EF Core, domain exceptions, and service layer. No skill set patterns.

- **Engine:** Transaction-specific (`WorkflowEngine` knows about transactions)
- **Error handling:** Domain exceptions â†’ ProblemDetails middleware
- **State flexibility:** Fixed â€” changing state combinations requires code changes
- **Extensibility:** Adding "Orders" requires new code (engine + tables + service)
- **Best for:** Evaluators who want to see exactly what they asked for

### Approach B â€” "DNA-Infused Multi-Tenant Engine"

The platform play. Introduces an `EntityType` discriminator â€” one set of database tables manages workflows for **any entity type** simultaneously. **Easiest to change state combinations later** because the engine is fully data-driven and scoped by entity type.

- **Engine:** Entity-agnostic (`TryTransitionAsync("transaction", ...)`)
- **Error handling:** `DataProcessResult<T>` â†’ `ResultMapper` â†’ ProblemDetails
- **State flexibility:** Maximum â€” add/remove/rewire states and transitions via SQL only, per entity type, even per tenant
- **Extensibility:** Adding "Orders" = SQL INSERT only, **zero code changes**
- **Best for:** Evaluators who value architectural vision and platform thinking

### Approach D â€” "Strategic Hybrid"

The sweet spot. Looks like a standard .NET project on the outside, but uses data-driven patterns on the inside. 80% of B's benefits with 20% of the complexity. Has the JSON `Rules` column and `DataProcessResult`, but lacks B's `EntityType` scoping â€” meaning it handles one workflow type per deployment.

- **Engine:** Generic (depends only on `IWorkflowRepository`, not entity repos)
- **Error handling:** `DataProcessResult<T>` â†’ `ResultMapper` â†’ ProblemDetails
- **State flexibility:** Good â€” add/remove states via SQL, dynamic rules via JSON, but single entity scope
- **Extensibility:** JSON rules in DB for dynamic business logic, new adapter code for new entities
- **Best for:** Evaluators who want clean code PLUS evidence of deeper thinking

### Which Approach Is Easiest to Change State Combinations Later?

**Approach B wins decisively.** The `EntityType` field on `WorkflowStatus` and `WorkflowTransition` turns the state machine from a single hardwired graph into a **registry of unlimited graphs**, all managed via data. The engine code is truly generic â€” it receives `entityType` as a parameter and looks up that type's graph from the database.

D is a solid middle ground â€” it has `DataProcessResult` and `Rules` which make it maintainable. But the moment you need a second workflow type (orders, support tickets), you're essentially rewriting D into B.

A requires code changes for almost any non-trivial state combination change.

---

## ğŸ§ª The "Data, Not Code" Test

> *"Can a business user change the workflow without a developer?"*

### Core Capabilities

| Capability | A | B | D |
|------------|---|---|---|
| Add new status | âœ… SQL INSERT | âœ… SQL INSERT (scoped by EntityType) | âœ… SQL INSERT |
| Add new entity type (e.g. Orders) | âŒ New code | âœ… **SQL only â€” zero code** | âŒ New adapter code |
| Add business rule (e.g. maxRetries) | âŒ C# change | âœ… JSON column + generic evaluator | âœ… JSON column + generic evaluator |
| Swap database provider | âŒ Coupled to EF | ğŸŸ¡ Behind interfaces | ğŸŸ¡ Behind interfaces |

### State Combination Change Scenarios

These scenarios reveal the real cost of changing workflows after deployment:

| Scenario | A | D | B |
|----------|---|---|---|
| **Add "ON_HOLD" between PROCESSING â†’ COMPLETED** | âœ… SQL INSERT | âœ… SQL INSERT + Rules | âœ… SQL INSERT + Rules |
| **Add "order" workflow (PENDING â†’ SHIPPED â†’ DELIVERED)** | ğŸ”´ New engine + tables + service | ğŸ”´ Add EntityType column, refactor engine â€” essentially rewrite into B | ğŸŸ¢ **SQL INSERT only â€” zero code** |
| **Same entity, different workflow per tenant** | ğŸ”´ Impossible | ğŸ”´ Impossible â€” single scope | ğŸŸ¢ Use EntityType as composite key (`"transaction-clientA"` vs `"transaction-clientB"`) |
| **Add role-based permission to a transition** | ğŸ”´ Hardcode `if (role == "Admin")` | ğŸŸ¢ Add JSON rule `{"allowedRoles":["Manager"]}` + 10-line evaluator | ğŸŸ¢ Same as D â€” rules engine exists |
| **Remove "FAILED â†’ VALIDATED" retry path** | âœ… DELETE SQL row | âœ… DELETE SQL row | âœ… DELETE SQL row |

---

## ğŸ› ï¸ Skill Set Integration

Each approach maps to the skill library from previous implementations at a different depth:

| Skill | Purpose | A | B | D |
|-----------|---------|---|---|---|
| **Skill 01** â€” Core Interfaces / DataProcessResult | Structured errors, no exceptions | âŒ Exceptions | âœ… Full | âœ… Full |
| **Skill 02** â€” Object Processor / JSON Rules | Dynamic business rules as data | âŒ | âœ… Full | âœ… Full |
| **Skill 05** â€” Database Fabric | Generic data access patterns | âœ… EF Core | âœ… EF Core + JSON | âœ… EF Core + JSON |
| **Skill 08** â€” Flow Definition | Workflow as data, not code | âœ… DB rows | âœ… EntityType-scoped | âœ… DB rows |
| **Skill 09** â€” Flow Orchestrator | State machine engine | âœ… Specific | âœ… Generic (multi-tenant) | âœ… Generic (single-tenant) |
| **Skill 15** â€” API Gateway | HTTP â†” domain mapping | âœ… Middleware | âœ… ResultMapper | âœ… ResultMapper |
| **Skill 29** â€” Testing | Automated quality assurance | âœ… xUnit | âœ… xUnit + isolation | âœ… xUnit |
| **Skill 45** â€” Design Patterns | Decorator, Adapter, Strategy | âœ… Decorator | âœ… All three | âœ… All three |

### The Core Philosophy â€” "Data, Not Code"

The skill set is built around one principle: **if a business user might want to change it, it must be data, not code.**

- **MACHINE** = generic logic that never changes (the workflow engine, the result mapper, the repository interfaces)
- **FREEDOM** = configuration that business users control (statuses, transitions, rules â€” all in the database)

Approach A puts everything in the MACHINE. Approach B maximizes FREEDOM. Approach D finds the strategic balance.

---

## ğŸ“¡ API Endpoints (All Approaches)

### Core â€” Transactions

| Method | Endpoint | Description |
|--------|----------|-------------|
| `POST` | `/transactions` | Create a new transaction |
| `GET` | `/transactions/{id}` | Get transaction by ID |
| `POST` | `/transactions/{id}/transition` | Transition to a new status |
| `GET` | `/transactions/{id}/available-transitions` | List valid next statuses |
| `GET` | `/transactions/{id}/history` | Status change audit trail |

### Bonus â€” Admin Workflow Management

| Method | Endpoint | Description |
|--------|----------|-------------|
| `GET` | `/admin/workflow/statuses` | List all workflow statuses |
| `POST` | `/admin/workflow/statuses` | Add a new status |
| `GET` | `/admin/workflow/transitions` | List all transitions |
| `POST` | `/admin/workflow/transitions` | Add a new transition |
| `GET` | `/admin/workflow/visualize` | Mermaid.js workflow diagram |
| `GET` | `/health` | Health check with DB connectivity |

### Seeded Workflow
```
CREATED â†’ VALIDATED â†’ PROCESSING â†’ COMPLETED
                               â†˜ FAILED â†’ VALIDATED (retry)
```

---

## ğŸ“– Documentation Map

| Document | What It Covers |
|----------|---------------|
| [`approach_analysis.md`](approach_analysis.md) | Deep dive into all 4 approaches (A, B, C, D) with phase plans, skill mapping, positive/negative examples, and recovery strategy |
| [`approaches_comparison.md`](approaches_comparison.md) | Side-by-side flow comparison: how Create Transaction and Execute Transition work differently in A vs B vs D |
| [`cto_analysis.jsx`](cto_analysis.jsx) | Interactive architectural decision dashboard: tradeoff analysis, cost modeling, risk scenarios, team composition guidance |
| [`approach_analysis.jsx`](approach_analysis.jsx) | Interactive React component for visual approach comparison |
| [`CodeDocumentation.docx`](CodeDocumentation.docx) | Directory scheme + layer-by-layer code documentation for all 3 approaches |
| [`ApproachComparison.docx`](ApproachComparison.docx) | Architectural differences + decision matrix (Word format) |
| [`BugInvestigation_SKILL.md`](BugInvestigation_SKILL.md) | EF Core tracking conflict debugging methodology â€” 5-layer investigation framework |
| [`FINAL_STATE.md`](FINAL_STATE.md) | Phase 1â€“11 completion tracking (V2): infrastructure, validation, error standards, security, bug fixes, reviewer feedback |
| [`TEST_REPORT.md`](TEST_REPORT.md) | Auto-generated test results from `testAll.ps1` (45 tests across 3 approaches â€” 15 each) |

### Phase Progression (Phases 1â€“11)

```
Phase 1: DevOps Foundation          Phase 2: Input Validation       Phase 3: API Quality
  â”œâ”€ Docker healthcheck               â”œâ”€ FluentValidation              â”œâ”€ RFC 7807 ProblemDetails
  â”œâ”€ .env secrets extraction          â””â”€ Fix B duplicate var bug       â””â”€ Mermaid visualization
  â””â”€ start.sh one-command launch
          â”‚                                     â”‚                              â”‚
          â–¼                                     â–¼                              â–¼
Phase 4: Documentation              Phase 5: Engine Purity          Phase 6: API Resilience
  â””â”€ skill-mapped READMEs               â”œâ”€ D: Remove ITransactionRepo    â”œâ”€ B,D: GlobalExceptionMiddleware
                                       â”‚   from WorkflowEngine          â”œâ”€ A: ProblemDetails upgrade
                                       â””â”€ D: Pass priorTransition       â””â”€ All: /health endpoint
                                            Count from service
          â”‚                                     â”‚                              â”‚
          â–¼                                     â–¼                              â–¼
Phase 7: Config Cleanup             Phase 8: Skill Integration      Phase 9: Bug Fixes (Critical)
  â”œâ”€ Remove hardcoded passwords        â”œâ”€ AI configs (Copilot,          â”œâ”€ AsNoTracking on cached queries
  â”œâ”€ .env.example for onboarding       â”‚   Claude Code)                 â”œâ”€ FK-only navigation assignment
  â””â”€ Fix Infrastructure csproj         â””â”€ Skill maps + architecture     â””â”€ Entity reload after mutation
                                            docs
          â”‚                                     â”‚                              â”‚
          â–¼                                     â–¼                              â–¼
Phase 10: Security Hardening        Phase 11: Reviewer Fixes
  â”œâ”€ API Key Auth + dev-bypass         â”œâ”€ Concurrency/Idempotency docs
  â”œâ”€ Authorize + AdminOnly policy      â”œâ”€ Rule evaluator safety docs
  â”œâ”€ CORS configuration               â”œâ”€ CTO-choice framing fix
  â”œâ”€ Env-aware exception detail        â””â”€ Workflow diagram fix
  â””â”€ XML docs in Swagger                       â”‚
                                                â–¼
                                       âœ… ALL 45 TESTS PASSING
```

---

## ğŸ”¨ buildAll.ps1 â€” What It Does

```
1. Extracts all 3 zips into folders
2. Patches B & D: moves a `using` statement from mid-file to top (cosmetic fix)
3. Runs `dotnet restore` + `dotnet build` for each approach
4. Reports build status with error highlighting
```

> **Note:** `testAll.ps1` applies an additional runtime fix: `Migrate()` â†’ `EnsureCreated()` in `Program.cs` because no EF migration files exist in the zips. The `buildAll.ps1` only handles compilation â€” the migration fix is only needed when actually running the containers.

Expected output:
```
=== TransactionWorkflow_ApproachA ===
Build succeeded.    0 Warning(s)    0 Error(s)
BUILD OK

=== TransactionWorkflow_ApproachB ===
Build succeeded.    0 Warning(s)    0 Error(s)
BUILD OK

=== TransactionWorkflow_ApproachD ===
Build succeeded.    0 Warning(s)    0 Error(s)
BUILD OK
```

---

## ğŸ§ª testAll.ps1 â€” Full Integration Test Suite (v2)

Runs Docker-based end-to-end tests against all 3 approaches sequentially. For each approach it extracts fresh from zip, applies automatic fixes, spins up containers, waits for the API, runs 15 tests, tears down, and moves to the next.

### Usage
```powershell
.\testAll.ps1
```

### Automatic Fixes Applied Before Testing

The script detects and patches known issues before building each approach:

| Fix | What | Why |
|-----|------|-----|
| `Migrate()` â†’ `EnsureCreated()` | Replaces EF migration call in `Program.cs` | No EF migration files exist â€” `EnsureCreated()` builds schema from model |
| Misplaced `using` | Moves `using TransactionWorkflow.API.Middleware;` to top of file (B, D) | Prevents compilation error |
| Entity-type routes | Uses `/admin/workflow/transaction/` for Approach B | B's multi-tenant admin routes are scoped by entity type |

### What It Tests

| # | Test | Category | Validates |
|---|------|----------|-----------|
| T1 | Docker Build | Infrastructure | Container builds successfully |
| T2 | API Startup | Infrastructure | API responds on configured port |
| T3 | Create Transaction | Happy Path | `POST /transactions` returns ID + CREATED status |
| T4 | Get Transaction | Happy Path | `GET /transactions/{id}` returns correct status |
| T5 | Available Transitions | Happy Path | CREATED â†’ VALIDATED is listed |
| T6 | Transition to VALIDATED | Happy Path | Status changes to VALIDATED |
| T7 | Transition to PROCESSING | Happy Path | Status changes to PROCESSING |
| T8 | Transition to COMPLETED | Happy Path | Full workflow CREATED â†’ COMPLETED |
| T9 | Transaction History | Happy Path | At least 3 history entries after full workflow |
| T10 | Bad Input â†’ 400 | Error Path | Negative amount + invalid currency rejected |
| T11 | Invalid Transition â†’ 400 | Error Path | CREATED â†’ COMPLETED skipped, returns 400 |
| T12 | Not Found â†’ 404 | Error Path | Non-existent transaction ID returns 404 |
| T13 | Workflow Visualization | Features | `GET /admin/workflow/visualize` returns Mermaid graph |
| T14 | Admin: Get Statuses | Features | At least 4 seeded statuses returned |
| T15 | Admin: Get Transitions | Features | At least 4 seeded transitions returned |

### Test Flow Per Approach
```
Extract zip â†’ Fix Migrate/using/routes â†’ docker-compose up â†’ Wait for API (90s max)
â†’ Run 15 API tests (with error body capture) â†’ docker-compose down â†’ Next approach
```

### Output
```
============================================================
  FINAL REPORT
============================================================

  Approach A (Vanilla)
  --------------------------------------------------
    [PASS] Docker Build
    [PASS] API Startup
    [PASS] Create Transaction
    ...

  Approach B (Multi-Tenant DNA)
  --------------------------------------------------
    [PASS] Docker Build
    ...

  Approach D (Strategic Hybrid)
  --------------------------------------------------
    [PASS] Docker Build
    ...

  TOTAL: 45 passed, 0 failed  |  Time: ~2 min
============================================================
```

A `TEST_REPORT.md` is auto-generated with the full results table, fix log, and per-test detail column.

---

## ğŸ”¬ Deep Dive: How the Approaches Differ

The three approaches solve the same API contract but diverge fundamentally in how the **engine** and **database** work together.

### The Engine Signature â€” The Key Differentiator

**Approach A** â€” the engine knows it's dealing with a Transaction:
```csharp
public async Task TransitionAsync(Transaction transaction, string targetStatus)
{
    // Queries specific "TransactionTransitions" table
}
```

**Approach D** â€” the engine is generic in behavior but still single-tenant:
```csharp
public async Task<DataProcessResult<TransitionOutcome>> TryTransitionAsync(
    int currentStatusId, string targetStatus, int priorTransitionCount, ...)
{
    // Queries "WorkflowTransitions" table (single scope)
}
```

**Approach B** â€” the engine doesn't know what a "Transaction" is:
```csharp
public async Task<DataProcessResult<TransitionOutcome>> TryTransitionAsync(
    string entityType,           // â† THE KEY DIFFERENTIATOR
    string currentStatusName, int currentStatusId, string targetStatusName, ...)
{
    // Queries SHARED table filtered by EntityType
    var allowed = await _repo.GetAllowedTransitionsAsync(entityType, currentStatusId);
}
```

### Flow Comparison: Creating a Transaction

| Step | Approach A | Approach B | Why B differs |
|------|-----------|-----------|---------------|
| Service call | `_engine.GetInitialStatusAsync()` | `_engine.GetInitialStatusAsync("transaction")` | B needs the `entityType` to find the right workflow in shared tables |
| DB query | `WHERE IsInitial = 1` | `WHERE IsInitial = 1 AND EntityType = 'transaction'` | Same table holds initial states for Orders, Tickets, etc. |
| Result | `WorkflowStatus` | `WorkflowStatus` | Same output, different source scope |

### Flow Comparison: Executing a Transition

| Step | Approach A | Approach B | Architectural shift |
|------|-----------|-----------|-------------------|
| Adapter | `engine.TransitionAsync(txn, target)` | `engine.TryTransitionAsync("transaction", ...)` | B's `TransactionService` acts as an Adapter from specific â†’ generic |
| Isolation | Checks `FromId` / `ToId` | Checks `FromId` / `ToId` **AND** `EntityType` | B ensures a Transaction can't use an Order's transition rule |
| Extensibility | New entity = new engine + tables + service | New entity = **SQL INSERT only** | B achieves the "data, not code" ideal |
| DB design | FK to `TransactionStatus` | FK to `WorkflowStatus` + composite index `(EntityType, Name)` | Uniqueness within scope, not globally |

### Summary of Tradeoffs

| Dimension | A (Vanilla) | B (Multi-Tenant) | D (Hybrid) |
|-----------|-------------|-------------------|------------|
| Complexity | Low | High (conceptually) | Medium |
| Flexibility | Low | **Maximum** | Medium (JSON rules) |
| State change cost | ğŸ”´ Code changes likely | ğŸŸ¢ **SQL only â€” always** | ğŸŸ¡ SQL for single type, code for multi |
| Code reuse | None | **Total** (shared engine) | High (patterns) |
| New entity cost | New engine + tables + service | **Zero code â€” SQL only** | New adapter + service |
| Tenant isolation | âŒ Not possible | âœ… `EntityType` composite key | âŒ Not possible |
| Dynamic transition rules | âŒ Not supported | âœ… JSON `Rules` column + evaluator | âœ… JSON `Rules` column + evaluator |
| `DataProcessResult` | âŒ Throws exceptions | âœ… Structured results + metadata | âœ… Structured results + metadata |
| Dynamic entity metadata | âŒ Fixed schema | âœ… `Metadata` JSON column | âœ… `Metadata` JSON column |
| Best for | Single microservice | Platform / monolith core | Enterprise microservice |

### The 4 Key Architectural Differences

These are the structural decisions that determine each approach's flexibility:

| Feature | A | D | B |
|---------|---|---|---|
| **EntityType scoping** | âŒ Global statuses | âŒ Global statuses | âœ… Per-entity-type |
| **Dynamic transition Rules** | âŒ None | âœ… `Dictionary<string,object>` | âœ… `Dictionary<string,object>` + evaluation |
| **DataProcessResult** | âŒ Throws exceptions | âœ… Yes | âœ… Yes + `WithMeta` chain |
| **Transaction Metadata** | âŒ Fixed schema | âœ… Dynamic dict | âœ… Dynamic dict |

B's `EntityType` field is the critical differentiator. It turns the state machine from a **single hardwired graph** into a **registry of unlimited graphs**, all managed via data. D is the pragmatic choice for a single-entity system that may grow; B is the correct choice if multi-entity or multi-tenant workflows are even remotely likely.

---

## ğŸ”® Extension Roadmap â€” From "Transaction Engine" to "Workflow Platform"

Each approach shipped here solves the assignment. The extensions below are **not implemented** â€” they are architectural suggestions showing how the skill set patterns would scale to real-world requirements. They demonstrate **why** the pattern choices matter: what costs one line in Approach B costs a full rebuild in Approach A.

> **Execution strategy:** The `agent.md` file contains ready-to-use AI prompts (for Copilot, Claude, Cursor) that implement each extension following skill set patterns. The `.ai-config/v17-skill-library.md` file serves as the "rule book" â€” upload it before any AI session to enforce correct patterns.

### The Architecture Strategy

Before implementing, understand **why** each extension maps to a specific skill:

| Extension | Skill | Architectural Principle |
|-----------|-----------|----------------------|
| Configurable Tasks | Skill 05 (Database Fabric) | Don't add columns â€” use a JSON data column |
| Multi-Project Workflows | Skill 08 (Flow Definition) | Add a scope discriminator, not new tables |
| Role-Based Permissions | Skill 02 (Object Processor) | Permissions are JSON rules, not `if` statements |
| SSO / Flexible Auth | Skill 15 (API Gateway) | Auth config lives in `appsettings.json`, not in code |

### Extension 1: Configurable Tasks (JSON Data Columns)

**Problem:** Different departments want different fields â€” Sales needs "Priority", Finance needs "DueDate", Support needs "CustomerSegment". Adding columns for each is unsustainable.

**Pattern:** Skill 05 (Database Fabric) â€” add a `Dictionary<string, object> Data` property stored as a JSON column via EF Core `ValueConversion`. No schema changes needed per field.

```csharp
// Example of how the API would look after implementing this extension:
POST /transactions
{ "amount": 500, "currency": "USD", "metadata": { "priority": "high", "department": "sales" } }
```

| Approach | Effort | How |
|----------|--------|-----|
| A | ğŸŸ¡ Medium | Add JSON column + ValueConverter to Transaction entity |
| B | âœ… Already done | `Metadata` dictionary already exists on Transaction |
| D | âœ… Already done | `Metadata` dictionary already exists on Transaction |

> **AI Prompt (from agent.md):** *"Add a `JsonDocument` property named `Data` to the Transaction entity. Configure EF Core `ValueConversion` to store as JSON string. Update the DTO to accept `Dictionary<string, object> Data`. Constraint: Do not add specific columns like 'DueDate' to the SQL table."*

### Extension 2: Multi-Project Workflows

**Problem:** Project A needs "ToDo â†’ Done" while Project B needs "Draft â†’ Review â†’ Publish". One workflow doesn't fit all.

**Pattern:** Skill 08 (Flow Definition) â€” add a nullable `ProjectId` foreign key to `WorkflowStatus` and `WorkflowTransition`. Project-specific transitions override global defaults. The repository implements fallback logic: look for project-specific transitions first, fall back to global if none found.

```sql
-- Project-scoped workflow (no code changes in B)
INSERT INTO WorkflowStatuses (EntityType, Name, IsInitial, ProjectId)
VALUES ('task', 'DRAFT', 1, @projectBId);
```

| Approach | Effort | How |
|----------|--------|-----|
| A | ğŸ”´ High | New tables, new engine, new service â€” fundamental restructuring |
| B | ğŸŸ¢ Low | Add `ProjectId` column + repository fallback logic. `EntityType` scoping already provides the foundation |
| D | ğŸŸ¡ Medium | Add `ProjectId` + update repository queries + update engine interface |

> **AI Prompt (from agent.md):** *"Create a `Project` entity (Id, Name, Key). Update `WorkflowStatus` and `WorkflowTransition` to include nullable `ProjectId` FK. Update the repository: when loading transitions for Project X, look for specific transitions first; fallback to global if none found. Constraint: The WorkflowEngine interface must not change."*

### Extension 3: Role-Based Transition Permissions

**Problem:** Only managers should be able to approve transitions from "Validated" to "Processing". Currently anyone can.

**Pattern:** Skill 02 (Object Processor) â€” permissions are **data, not code**. Store `{ "allowedRoles": ["Manager", "Admin"] }` in the transition's `Rules` JSON column. The generic `RuleEvaluator` checks it. The API Gateway (Skill 15) extracts user claims from the JWT token and passes them into the engine's `context` dictionary. The engine never imports auth libraries â€” it just reads keys from the context.

```json
// WorkflowTransitions.Rules column:
{ "allowedRoles": ["Manager", "Admin"], "maxRetries": 3 }
```

```csharp
// Controller extracts claims and passes to engine â€” engine stays auth-free:
var userRoles = HttpContext.User.Claims.Where(c => c.Type == ClaimTypes.Role).Select(c => c.Value).ToList();
var context = new Dictionary<string, object> { ["UserRoles"] = userRoles };
await _engine.TryTransitionAsync(statusId, target, context: context);
```

| Approach | Effort | How |
|----------|--------|-----|
| A | ğŸ”´ High | No rules engine â€” hardcode `if (role == "Admin")` in controller, doesn't scale |
| B | ğŸŸ¢ Low | Add `allowedRoles` key to `EvaluateTransitionRules` â€” ~10 lines of code |
| D | ğŸŸ¢ Low | Same as B â€” rules engine already exists in `EvaluateTransitionRules` |

> **AI Prompt (from agent.md):** *"Permissions are defined in the database by adding `{ 'allowedRoles': ['Manager', 'Admin'] }` to WorkflowTransition.Rules JSON. Extend `EvaluateTransitionRules` to check if the context dictionary contains a `UserRoles` list and validate against the rule. In the controller, extract roles from `HttpContext.User` claims and pass via context. Do NOT hardcode roles in C#."*

### Extension 4: SSO / Flexible Authentication

**Problem:** Customer A uses Azure AD, Customer B uses Okta, Customer C uses Google. Need to support all without code changes.

**Pattern:** Skill 15 (API Gateway) â€” auth configuration lives in `appsettings.json`, not in code. A Strategy Pattern reads `Authority`, `ClientId`, `Audience` from config and wires up `JwtBearer` automatically.

```json
// appsettings.json â€” swap SSO provider with zero code:
"Auth": { "Authority": "https://login.microsoftonline.com/...", "ClientId": "...", "Audience": "..." }
```

**Key constraint:** The Domain project never depends on auth libraries. Authentication is purely an API/Infrastructure concern.

| Approach | Effort | How |
|----------|--------|-----|
| A | ğŸŸ¡ Medium | Add `AddFlexibleAuth()` extension in API project |
| B | ğŸŸ¡ Medium | Same â€” auth is orthogonal to the engine |
| D | ğŸŸ¡ Medium | Same â€” auth is orthogonal to the engine |

> **AI Prompt (from agent.md):** *"Implement a Strategy Pattern for auth in `Program.cs`. Create `AuthSettings` in `appsettings.json` with Authority, ClientId, Audience. Create an `AddFlexibleAuth(configuration)` extension that reads settings and configures JwtBearer. Constraint: The Domain project must NOT depend on any Auth libraries."*

### Extension Summary

| Extension | Skill | A | B | D |
|-----------|-----------|---|---|---|
| Configurable tasks (JSON fields) | Skill 05 | ğŸŸ¡ Add column | âœ… Already built | âœ… Already built |
| Multi-project workflows | Skill 08 | ğŸ”´ Rebuild | ğŸŸ¢ Add scope column | ğŸŸ¡ Add scope + refactor |
| Role-based permissions | Skill 02 | ğŸ”´ Hardcode | ğŸŸ¢ Add JSON rule key | ğŸŸ¢ Add JSON rule key |
| SSO / flexible auth | Skill 15 | ğŸŸ¡ Config extension | ğŸŸ¡ Config extension | ğŸŸ¡ Config extension |

### How to Execute These Extensions

1. **Prepare:** Save the `.ai-config/v17-skill-library.md` file in your repo (already included).
2. **Context:** Start a new chat with Copilot/Claude/Cursor. Attach the library file + `CLAUDE.md`.
3. **Execute:** Paste the prompts from `agent.md` one by one:
   - Start with Extension 1 (Configurable Tasks) â€” updates the core entity
   - Move to Extension 2 (Multi-Project) â€” updates the schema and scoping
   - Implement Extension 3 (Permissions) â€” leverages the JSON rules
   - Finish with Extension 4 (SSO) â€” secures the API

> **Note:** Each extension builds on the previous. Extension 2 benefits from Extension 1's JSON column pattern. Extension 3 requires the `Rules` JSON column that B and D already have. Extension 4 is orthogonal and can be done at any point.

---

## ğŸ§  AI Agent Configuration

Each approach ships with pre-configured AI agent context files:

| Agent | Config File | Purpose |
|-------|-------------|---------|
| GitHub Copilot | `.github/copilot-instructions.md` | Inline suggestions following skill set patterns |
| Claude Code | `CLAUDE.md` | Project-aware coding with architecture rules |
| General / Any AI | `.ai-config/project-architecture.md` | Philosophy + pattern reference |
| Skill Library | `.ai-config/v17-skill-library.md` | skill â†’ actual file mapping |
| Extension Prompts | `agent.md` | Copy-paste prompts for implementing Extensions 1â€“4 |

The `.ai-config/` folder contains prompt-engineered context so AI agents extend the project using the correct patterns (DataProcessResult, JSON rules, generic engines) instead of writing legacy code.

### Using the Skill Library with AI Agents

The `v17-skill-library.md` file (named after the internal skill set version) acts as a rule book that enforces 5 core skills:

| Skill | Rule | AI Must... |
|-------|------|-----------|
| **Skill 01** (Core Interfaces) | All business logic returns `DataProcessResult<T>` | Never throw exceptions for logical failures |
| **Skill 02** (Object Processor) | Business rules are JSON configuration, not code | Use `RuleEvaluator` to parse `allowedRoles`, `minAmount`, `maxRetries` |
| **Skill 05** (Database Fabric) | Dynamic requirements use JSON columns | Never alter schema for new field requirements |
| **Skill 08** (Flow Definition) | Workflows are defined by data, not code | Scope by `ProjectId` or `EntityType`, not by new classes |
| **Skill 15** (API Gateway) | API layer translates, never contains logic | Extract claims from tokens â†’ inject into engine context |

**Workflow:** Upload `v17-skill-library.md` + `CLAUDE.md` at the start of any AI session â†’ paste prompts from `agent.md` â†’ AI follows the rules instead of writing legacy patterns.

---

## ğŸ‘” Why Three Approaches? â€” Architectural Decision-Making

> See [`cto_analysis.jsx`](cto_analysis.jsx) for an interactive dashboard with cost modeling, risk scenarios, and team fit analysis.

I deliberately built three implementations of the same assignment â€” not to pad the submission, but because **the right architecture depends on context that only the hiring team has:** team composition, product roadmap, and what features are coming next. Rather than guessing which one fits, I built all three as working proof-of-concepts so a CTO can evaluate the tradeoffs with code, not slides.

### The Approach â€” Skills-Driven Vibe Coding

Each approach was built using a **skills directory** â€” a library of documented patterns distilled from projects I've implemented in the past. The idea is straightforward: invest upfront in thorough documentation and reusable skill definitions so that architectural decisions can be made by reading docs, not digging into code.

This has a practical payoff beyond the assignment itself:

- **Decision-making without code review.** The documentation map, comparison tables, and interactive dashboards are designed to give a technical lead the full picture in minutes â€” which approach fits, what the tradeoffs are, and what changes later.
- **Continuity for future teams.** The `.ai-config/` folders, `CLAUDE.md`, and `copilot-instructions.md` files inside each approach mean that any developer â€” using any AI-assisted coding platform (Copilot, Claude Code, Cursor, or others) â€” can pick up the project and continue building with the same patterns. The skills directory acts as institutional knowledge that travels with the repo.
- **Vibe coding at scale.** The prompts in the AI config files aren't generic â€” they encode the specific architectural rules (DataProcessResult over exceptions, JSON rules over hardcoded logic, FK-only assignments) so AI assistants generate code that fits the existing codebase rather than defaulting to textbook patterns.

The goal is that whichever approach the team picks, the next developer can start contributing on day one with their preferred tools.

### Which Approach Fits? â€” It Depends

**Approach D** is the middle ground â€” it meets every requirement with a standard .NET stack and includes enough abstraction (DataProcessResult, JSON Rules) to show how the patterns scale, without unnecessary complexity.

**Approach B** shows what happens when you design for a platform from day one â€” the `EntityType` discriminator makes adding new workflow types a SQL-only operation. Whether that's worth the upfront investment depends entirely on the roadmap.

**Approach A** is the simplest solution that meets the requirements. For a small team or a feature that won't grow, this might genuinely be the right fit.

### Tradeoff Analysis

| Decision Factor | A (Vanilla) | B (Platform) | D (Hybrid) |
|----------------|-------------|--------------|------------|
| **Initial delivery speed** | ğŸŸ¢ Fastest (4â€“5h) | ğŸ”´ Slowest (5â€“7h) | ğŸŸ¡ Middle (6â€“8h) |
| **PM says "add Orders next quarter"** | ğŸ”´ Full feature build (weeks) | ğŸŸ¢ SQL INSERT (minutes) | ğŸŸ¡ Refactor into B (days) |
| **Different workflow per client/tenant** | ğŸ”´ Not possible | ğŸŸ¢ Composite EntityType key | ğŸ”´ Not possible |
| **New dev onboarding time** | ğŸŸ¢ 1â€“2 days | ğŸŸ¡ 3â€“5 days (needs DNA concepts) | ğŸŸ¢ 2â€“3 days |
| **Tech debt at 12 months** | ğŸ”´ High â€” patterns diverge per entity | ğŸŸ¢ Low â€” shared engine | ğŸŸ¡ Medium â€” single scope limits |
| **Probability of major refactor** | ğŸ”´ ~90% when scope grows | ğŸŸ¢ ~10% already generic | ğŸŸ¡ ~50% when 2nd entity arrives |

### The Cost Curve Behind the Decision

The key observation is that **the cost curves cross.** A is cheapest at month 1 but most expensive by month 12. B is most expensive at month 1 but cheapest once scope expands. D sits in between â€” a hedge that delays the B decision without the A penalty.

The crossover point depends on the product roadmap: if the scope stays narrow, D or even A may never become expensive. If new entity types are on the horizon, B's upfront cost pays for itself quickly. These tradeoffs are visualized in the [`cto_analysis.jsx`](cto_analysis.jsx) dashboard.

### Risk Scenarios to Consider

| What Could Go Wrong | A | B | D |
|---------------------|---|---|---|
| Scope creep â€” new entity types needed | ğŸ”´ Each is a project | ğŸŸ¢ Each is a SQL script | ğŸŸ¡ Refactor required |
| Junior dev introduces EF tracking bug | ğŸ”´ Exception swallowed in middleware | ğŸŸ¢ DataProcessResult surfaces errors explicitly | ğŸŸ¢ Same â€” structured results |
| Security audit flags open admin endpoints | ğŸŸ¢ V2: Resolved (API Key + AdminOnly) | ğŸŸ¢ V2: Resolved | ğŸŸ¢ V2: Resolved |
| Need to swap database or add second provider | ğŸ”´ EF tightly coupled | ğŸŸ¢ Generic interfaces abstract storage | ğŸŸ¡ Interfaces exist but single impl |
| Production incident â€” unhandled exception | ğŸŸ¢ V2: Environment-aware middleware | ğŸŸ¢ V2: Same | ğŸŸ¢ V2: Same |

### Team Fit Considerations

Architecture isn't just about code â€” it's also about the team maintaining it:

| Team Shape | Best Fit | Why |
|------------|----------|-----|
| 3 juniors + 1 senior | A | Standard patterns, everyone contributes from day 1. Low coordination cost. |
| 2 mid-level + 1 staff/lead | D | Lead designs the abstraction layer, mid-levels implement within its guardrails. DataProcessResult and JSON Rules are learnable patterns. |
| Full senior / platform team | B | Everyone understands EntityType scoping. Enables parallel work â€” one dev adds Orders, another adds Tickets, no merge conflicts on the engine. |
| Solo developer / startup | D â†’ B | Start D to ship fast. Migrate to B when the second entity type arrives. The upgrade path is documented and the patterns are compatible. |

### The EF Tracking Bug â€” Systematic Debugging in Practice

During integration testing, a real production-class bug surfaced: 7 test failures across all 3 approaches traced to 2 root causes (EF entity tracking conflict + middleware error swallowing). Rather than just fixing it, the full investigation methodology is documented in [`BugInvestigation_SKILL.md`](BugInvestigation_SKILL.md) â€” covering the DI Lifetime Ã— Caching matrix, the three manifestations of tracking conflicts, and a decision tree for diagnosing 500 errors. The goal is to make this class of bug preventable for the next developer, not just fixed for this project.

### Points Worth Discussing

1. **Why three approaches instead of one?** There's no single "right" answer â€” the best choice depends on team composition, the product roadmap, and what features come next. All three are included as working proof-of-concepts so a CTO can evaluate the tradeoffs with a full picture rather than a single opinion.

2. **Scaling considerations at 10Ã— volume.** The main pressure point is cache invalidation under concurrent transitions. `IMemoryCache` is singleton while `DbContext` is scoped â€” at high volume the tracking conflict window grows. A natural next step would be Redis with pub/sub invalidation and RowVersion-based optimistic concurrency.

3. **The EF tracking bug and how it was resolved.** 7 test failures across 3 approaches traced to 2 root causes, documented as a reusable investigation methodology in [`BugInvestigation_SKILL.md`](BugInvestigation_SKILL.md) â€” covering the DI Lifetime Ã— Caching matrix and a decision tree for diagnosing 500 errors.

4. **Migration path from D to B in production.** Add `EntityType` column with default `'transaction'` (existing data auto-migrates). Dual-write period. Backfill. Swap engine to B's generic signature. Drop default constraint. Each step is reversible with zero downtime.
