# Transaction Workflow Engine ‚Äî Home Assignment

> **3 approaches** to the same backend assignment, each demonstrating a different level of architectural maturity using the XIIGen V17 "Freedom Machine" skill set.

---

## üìÇ Repository Structure

```text
sqlink-task/
‚îú‚îÄ‚îÄ TransactionWorkflow_ApproachA.zip    # Vanilla .NET Clean Architecture
‚îú‚îÄ‚îÄ TransactionWorkflow_ApproachB.zip    # DNA-Infused Multi-Tenant Engine
‚îú‚îÄ‚îÄ TransactionWorkflow_ApproachD.zip    # Strategic Hybrid (‚≠ê Recommended)
‚îú‚îÄ‚îÄ buildAll.ps1                         # One-click extract + build all 3
‚îú‚îÄ‚îÄ testAll.ps1                          # Full integration test suite v2 (Docker + API + auto-fixes)
‚îú‚îÄ‚îÄ Backend_Home_Assignment.docx         # Original assignment brief
‚îú‚îÄ‚îÄ Readme.md                            # ‚Üê You are here
‚îÇ
‚îú‚îÄ‚îÄ approach_analysis.md                 # Deep analysis of all 4 approaches (A, B, C, D)
‚îú‚îÄ‚îÄ approach_analysis.jsx                # Interactive React comparison UI
‚îú‚îÄ‚îÄ approaches_comparison.md             # Side-by-side flow comparison (A vs B vs D)
‚îú‚îÄ‚îÄ agent.md                             # V17 skill prompt library for AI-assisted extensions
‚îú‚îÄ‚îÄ .ai-config/v17-skill-library.md      # Rule book for AI agents (upload before any session)
‚îú‚îÄ‚îÄ plan_diagram.mermaid                 # Visual phase dependency graph
‚îÇ
‚îú‚îÄ‚îÄ FINAL_STATE.md                       # Phase 1‚Äì4 completion tracking
‚îú‚îÄ‚îÄ IMPROVEMENT_PLAN.md                  # Phase 5‚Äì7 (R1‚ÄìR7) improvement requirements
‚îú‚îÄ‚îÄ INTEGRATION_FINAL_STATE.md           # V17 skill integration final status
‚îî‚îÄ‚îÄ TEST_REPORT.md                       # Auto-generated by testAll.ps1
```

---

## üöÄ Quick Start ‚Äî Build & Run All 3

### Prerequisites
- .NET 8 SDK
- Docker & Docker Compose (for running)
- PowerShell (for `buildAll.ps1`)

### One Command
```powershell
.\buildAll.ps1
```

This script extracts all 3 zips, applies known patches, and builds each solution. After build succeeds, run any approach:

```bash
cd TransactionWorkflow_ApproachD     # or A, or B
./start.sh                            # Linux / Mac / WSL
# ‚Äî or ‚Äî
docker-compose up --build -d          # Windows native
# ‚Üí Swagger UI: http://localhost:5000/swagger
# ‚Üí Health Check: http://localhost:5000/health
```

### Run Tests
```bash
# Unit tests (no Docker required)
cd TransactionWorkflow_ApproachD
dotnet test

# Full integration tests ‚Äî all 3 approaches via Docker (from root)
.\testAll.ps1
```

> **‚ö†Ô∏è PowerShell Execution Policy Error?** If you see `cannot be loaded... is not digitally signed`, run with bypass:
> ```powershell
> powershell -ExecutionPolicy Bypass -File .\testAll.ps1
> powershell -ExecutionPolicy Bypass -File .\buildAll.ps1
> ```
> Or set it permanently for your user:
> ```powershell
> Set-ExecutionPolicy -Scope CurrentUser -ExecutionPolicy RemoteSigned
> ```

---

## üèóÔ∏è The 3 Approaches

### Approach A ‚Äî "Textbook Clean Architecture" (Vanilla)

The safe, expected solution. Classical .NET Clean Architecture with EF Core, domain exceptions, and service layer. No V17 patterns.

- **Engine:** Transaction-specific (`WorkflowEngine` knows about transactions)
- **Error handling:** Domain exceptions ‚Üí ProblemDetails middleware
- **State flexibility:** Fixed ‚Äî changing state combinations requires code changes
- **Extensibility:** Adding "Orders" requires new code (engine + tables + service)
- **Best for:** Evaluators who want to see exactly what they asked for

### Approach B ‚Äî "DNA-Infused Multi-Tenant Engine" ‚≠ê Most Flexible

The platform play. Introduces an `EntityType` discriminator ‚Äî one set of database tables manages workflows for **any entity type** simultaneously. **Easiest to change state combinations later** because the engine is fully data-driven and scoped by entity type.

- **Engine:** Entity-agnostic (`TryTransitionAsync("transaction", ...)`)
- **Error handling:** `DataProcessResult<T>` ‚Üí `ResultMapper` ‚Üí ProblemDetails
- **State flexibility:** Maximum ‚Äî add/remove/rewire states and transitions via SQL only, per entity type, even per tenant
- **Extensibility:** Adding "Orders" = SQL INSERT only, **zero code changes**
- **Best for:** Evaluators who value architectural vision and platform thinking

### Approach D ‚Äî "Strategic Hybrid" ‚≠ê Recommended Starting Point

The sweet spot. Looks like a standard .NET project on the outside, but uses Freedom Machine patterns on the inside. 80% of B's benefits with 20% of the complexity. Has the JSON `Rules` column and `DataProcessResult`, but lacks B's `EntityType` scoping ‚Äî meaning it handles one workflow type per deployment.

- **Engine:** Generic (depends only on `IWorkflowRepository`, not entity repos)
- **Error handling:** `DataProcessResult<T>` ‚Üí `ResultMapper` ‚Üí ProblemDetails
- **State flexibility:** Good ‚Äî add/remove states via SQL, dynamic rules via JSON, but single entity scope
- **Extensibility:** JSON rules in DB for dynamic business logic, new adapter code for new entities
- **Best for:** Evaluators who want clean code PLUS evidence of deeper thinking

### Which Approach Is Easiest to Change State Combinations Later?

**Approach B wins decisively.** The `EntityType` field on `WorkflowStatus` and `WorkflowTransition` turns the state machine from a single hardwired graph into a **registry of unlimited graphs**, all managed via data. The engine code is truly generic ‚Äî it receives `entityType` as a parameter and looks up that type's graph from the database.

D is a solid middle ground ‚Äî it has `DataProcessResult` and `Rules` which make it maintainable. But the moment you need a second workflow type (orders, support tickets), you're essentially rewriting D into B.

A requires code changes for almost any non-trivial state combination change.

---

## üß™ The "Freedom Machine" Test

> *"Can a business user change the workflow without a developer?"*

### Core Capabilities

| Capability | A | B | D |
|------------|---|---|---|
| Add new status | ‚úÖ SQL INSERT | ‚úÖ SQL INSERT (scoped by EntityType) | ‚úÖ SQL INSERT |
| Add new entity type (e.g. Orders) | ‚ùå New code | ‚úÖ **SQL only ‚Äî zero code** | ‚ùå New adapter code |
| Add business rule (e.g. maxRetries) | ‚ùå C# change | ‚úÖ JSON column + generic evaluator | ‚úÖ JSON column + generic evaluator |
| Swap database provider | ‚ùå Coupled to EF | üü° Behind interfaces | üü° Behind interfaces |

### State Combination Change Scenarios

These scenarios reveal the real cost of changing workflows after deployment:

| Scenario | A | D | B |
|----------|---|---|---|
| **Add "ON_HOLD" between PROCESSING ‚Üí COMPLETED** | ‚úÖ SQL INSERT | ‚úÖ SQL INSERT + Rules | ‚úÖ SQL INSERT + Rules |
| **Add "order" workflow (PENDING ‚Üí SHIPPED ‚Üí DELIVERED)** | üî¥ New engine + tables + service | üî¥ Add EntityType column, refactor engine ‚Äî essentially rewrite into B | üü¢ **SQL INSERT only ‚Äî zero code** |
| **Same entity, different workflow per tenant** | üî¥ Impossible | üî¥ Impossible ‚Äî single scope | üü¢ Use EntityType as composite key (`"transaction-clientA"` vs `"transaction-clientB"`) |
| **Add role-based permission to a transition** | üî¥ Hardcode `if (role == "Admin")` | üü¢ Add JSON rule `{"allowedRoles":["Manager"]}` + 10-line evaluator | üü¢ Same as D ‚Äî rules engine exists |
| **Remove "FAILED ‚Üí VALIDATED" retry path** | ‚úÖ DELETE SQL row | ‚úÖ DELETE SQL row | ‚úÖ DELETE SQL row |

---

## üõ†Ô∏è V17 Skill Set Integration

Each approach maps to the XIIGen V17 skill library at a different depth:

| V17 Skill | Purpose | A | B | D |
|-----------|---------|---|---|---|
| **Skill 01** ‚Äî Core Interfaces / DataProcessResult | Structured errors, no exceptions | ‚ùå Exceptions | ‚úÖ Full | ‚úÖ Full |
| **Skill 02** ‚Äî Object Processor / JSON Rules | Dynamic business rules as data | ‚ùå | ‚úÖ Full | ‚úÖ Full |
| **Skill 05** ‚Äî Database Fabric | Generic data access patterns | ‚úÖ EF Core | ‚úÖ EF Core + JSON | ‚úÖ EF Core + JSON |
| **Skill 08** ‚Äî Flow Definition | Workflow as data, not code | ‚úÖ DB rows | ‚úÖ EntityType-scoped | ‚úÖ DB rows |
| **Skill 09** ‚Äî Flow Orchestrator | State machine engine | ‚úÖ Specific | ‚úÖ Generic (multi-tenant) | ‚úÖ Generic (single-tenant) |
| **Skill 15** ‚Äî API Gateway | HTTP ‚Üî domain mapping | ‚úÖ Middleware | ‚úÖ ResultMapper | ‚úÖ ResultMapper |
| **Skill 29** ‚Äî Testing | Automated quality assurance | ‚úÖ xUnit | ‚úÖ xUnit + isolation | ‚úÖ xUnit |
| **Skill 45** ‚Äî Design Patterns | Decorator, Adapter, Strategy | ‚úÖ Decorator | ‚úÖ All three | ‚úÖ All three |

### The "Freedom Machine" Philosophy

The XIIGen V17 skill set is built around one principle: **if a business user might want to change it, it must be data, not code.**

- **MACHINE** = generic logic that never changes (the workflow engine, the result mapper, the repository interfaces)
- **FREEDOM** = configuration that business users control (statuses, transitions, rules ‚Äî all in the database)

Approach A puts everything in the MACHINE. Approach B maximizes FREEDOM. Approach D finds the strategic balance.

---

## üì° API Endpoints (All Approaches)

### Core ‚Äî Transactions

| Method | Endpoint | Description |
|--------|----------|-------------|
| `POST` | `/transactions` | Create a new transaction |
| `GET` | `/transactions/{id}` | Get transaction by ID |
| `POST` | `/transactions/{id}/transition` | Transition to a new status |
| `GET` | `/transactions/{id}/available-transitions` | List valid next statuses |
| `GET` | `/transactions/{id}/history` | Status change audit trail |

### Bonus ‚Äî Admin Workflow Management

| Method | Endpoint | Description |
|--------|----------|-------------|
| `GET` | `/admin/workflow/statuses` | List all workflow statuses |
| `POST` | `/admin/workflow/statuses` | Add a new status |
| `GET` | `/admin/workflow/transitions` | List all transitions |
| `POST` | `/admin/workflow/transitions` | Add a new transition |
| `GET` | `/admin/workflow/visualize` | Mermaid.js workflow diagram |
| `GET` | `/health` | Health check with DB connectivity |

### Seeded Workflow
```
CREATED ‚Üí VALIDATED ‚Üí PROCESSING ‚Üí COMPLETED
                               ‚Üò FAILED ‚Üí VALIDATED (retry)
```

---

## üìñ Documentation Map

| Document | What It Covers |
|----------|---------------|
| [`approach_analysis.md`](approach_analysis.md) | Deep dive into all 4 approaches (A, B, C, D) with phase plans, V17 skill mapping, positive/negative examples, and recovery strategy |
| [`approaches_comparison.md`](approaches_comparison.md) | Side-by-side flow comparison: how Create Transaction and Execute Transition work differently in A vs B vs D |
| [`agent.md`](agent.md) | V17 prompt library: copy-paste prompts for AI agents to implement configurable tasks, multi-project workflows, permissions, and SSO |
| [`approach_analysis.jsx`](approach_analysis.jsx) | Interactive React component for visual approach comparison |
| [`plan_diagram.mermaid`](plan_diagram.mermaid) | Phase dependency graph (DevOps ‚Üí Validation ‚Üí API Quality ‚Üí Documentation) |
| [`IMPROVEMENT_PLAN.md`](IMPROVEMENT_PLAN.md) | Requirements R1‚ÄìR7: engine purity, exception middleware, health checks, security, dependency fixes |
| [`FINAL_STATE.md`](FINAL_STATE.md) | Phase 1‚Äì4 completion: Docker healthchecks, FluentValidation, ProblemDetails, Mermaid visualization |
| [`INTEGRATION_FINAL_STATE.md`](INTEGRATION_FINAL_STATE.md) | V17 integration completion: AI configs, skill maps, code improvements across all 3 approaches |
| [`TEST_REPORT.md`](TEST_REPORT.md) | Auto-generated test results from `testAll.ps1` (33 tests across 3 approaches) |

---

## üî® buildAll.ps1 ‚Äî What It Does

```
1. Extracts all 3 zips into folders
2. Patches B & D: moves a `using` statement from mid-file to top (cosmetic fix)
3. Runs `dotnet restore` + `dotnet build` for each approach
4. Reports build status with error highlighting
```

> **Note:** `testAll.ps1` applies an additional runtime fix: `Migrate()` ‚Üí `EnsureCreated()` in `Program.cs` because no EF migration files exist in the zips. The `buildAll.ps1` only handles compilation ‚Äî the migration fix is only needed when actually running the containers.

Expected output:
```
=== TransactionWorkflow_ApproachA ===
Build succeeded.    0 Warning(s)    0 Error(s)
BUILD OK

=== TransactionWorkflow_ApproachB ===
Build succeeded.    0 Warning(s)    0 Error(s)
BUILD OK

=== TransactionWorkflow_ApproachD ===
Build succeeded.    0 Warning(s)    0 Error(s)
BUILD OK
```

---

## üß™ testAll.ps1 ‚Äî Full Integration Test Suite (v2)

Runs Docker-based end-to-end tests against all 3 approaches sequentially. For each approach it extracts fresh from zip, applies automatic fixes, spins up containers, waits for the API, runs 11 tests, tears down, and moves to the next.

### Usage
```powershell
.\testAll.ps1
```

### Automatic Fixes Applied Before Testing

The script detects and patches known issues before building each approach:

| Fix | What | Why |
|-----|------|-----|
| `Migrate()` ‚Üí `EnsureCreated()` | Replaces EF migration call in `Program.cs` | No EF migration files exist ‚Äî `EnsureCreated()` builds schema from model |
| Misplaced `using` | Moves `using TransactionWorkflow.API.Middleware;` to top of file (B, D) | Prevents compilation error |
| Entity-type routes | Uses `/admin/workflow/transaction/` for Approach B | B's multi-tenant admin routes are scoped by entity type |

### What It Tests

| # | Test | Category | Validates |
|---|------|----------|-----------|
| T1 | Create Transaction | Happy Path | `POST /transactions` returns ID + CREATED status |
| T2 | Get Transaction | Happy Path | `GET /transactions/{id}` returns correct status |
| T3 | Available Transitions | Happy Path | CREATED ‚Üí VALIDATED is listed |
| T4 | Full Workflow | Happy Path | CREATED ‚Üí VALIDATED ‚Üí PROCESSING ‚Üí COMPLETED |
| T5 | Transaction History | Happy Path | At least 3 history entries after full workflow |
| T6 | Bad Input ‚Üí 400 | Error Path | Negative amount + invalid currency rejected |
| T7 | Invalid Transition ‚Üí 400 | Error Path | CREATED ‚Üí COMPLETED skipped, returns 400 |
| T8 | Not Found ‚Üí 404 | Error Path | Non-existent transaction ID returns 404 |
| T9 | Workflow Visualization | Features | `GET /admin/workflow/visualize` returns Mermaid graph |
| T10 | Admin: Get Statuses | Features | At least 4 seeded statuses returned |
| T11 | Admin: Get Transitions | Features | At least 4 seeded transitions returned |

### Test Flow Per Approach
```
Extract zip ‚Üí Fix Migrate/using/routes ‚Üí docker-compose up ‚Üí Wait for API (90s max)
‚Üí Run 11 API tests (with error body capture) ‚Üí docker-compose down ‚Üí Next approach
```

### Output
```
============================================================
  FINAL REPORT
============================================================

  Approach A (Vanilla)
  --------------------------------------------------
    [PASS] Docker Build
    [PASS] API Startup
    [PASS] Create Transaction
    ...

  Approach B (Multi-Tenant DNA)
  --------------------------------------------------
    [PASS] Docker Build
    ...

  Approach D (Strategic Hybrid)
  --------------------------------------------------
    [PASS] Docker Build
    ...

  TOTAL: 33 passed, 0 failed  |  Time: 8.2 min
============================================================
```

A `TEST_REPORT.md` is auto-generated with the full results table, fix log, and per-test detail column.

---

## üî¨ Deep Dive: How the Approaches Differ

The three approaches solve the same API contract but diverge fundamentally in how the **engine** and **database** work together.

### The Engine Signature ‚Äî The Key Differentiator

**Approach A** ‚Äî the engine knows it's dealing with a Transaction:
```csharp
public async Task TransitionAsync(Transaction transaction, string targetStatus)
{
    // Queries specific "TransactionTransitions" table
}
```

**Approach D** ‚Äî the engine is generic in behavior but still single-tenant:
```csharp
public async Task<DataProcessResult<TransitionOutcome>> TryTransitionAsync(
    int currentStatusId, string targetStatus, int priorTransitionCount, ...)
{
    // Queries "WorkflowTransitions" table (single scope)
}
```

**Approach B** ‚Äî the engine doesn't know what a "Transaction" is:
```csharp
public async Task<DataProcessResult<TransitionOutcome>> TryTransitionAsync(
    string entityType,           // ‚Üê THE KEY DIFFERENTIATOR
    string currentStatusName, int currentStatusId, string targetStatusName, ...)
{
    // Queries SHARED table filtered by EntityType
    var allowed = await _repo.GetAllowedTransitionsAsync(entityType, currentStatusId);
}
```

### Flow Comparison: Creating a Transaction

| Step | Approach A | Approach B | Why B differs |
|------|-----------|-----------|---------------|
| Service call | `_engine.GetInitialStatusAsync()` | `_engine.GetInitialStatusAsync("transaction")` | B needs the `entityType` to find the right workflow in shared tables |
| DB query | `WHERE IsInitial = 1` | `WHERE IsInitial = 1 AND EntityType = 'transaction'` | Same table holds initial states for Orders, Tickets, etc. |
| Result | `WorkflowStatus` | `WorkflowStatus` | Same output, different source scope |

### Flow Comparison: Executing a Transition

| Step | Approach A | Approach B | Architectural shift |
|------|-----------|-----------|-------------------|
| Adapter | `engine.TransitionAsync(txn, target)` | `engine.TryTransitionAsync("transaction", ...)` | B's `TransactionService` acts as an Adapter from specific ‚Üí generic |
| Isolation | Checks `FromId` / `ToId` | Checks `FromId` / `ToId` **AND** `EntityType` | B ensures a Transaction can't use an Order's transition rule |
| Extensibility | New entity = new engine + tables + service | New entity = **SQL INSERT only** | B achieves the Freedom Machine ideal |
| DB design | FK to `TransactionStatus` | FK to `WorkflowStatus` + composite index `(EntityType, Name)` | Uniqueness within scope, not globally |

### Summary of Tradeoffs

| Dimension | A (Vanilla) | B (Multi-Tenant) | D (Hybrid) |
|-----------|-------------|-------------------|------------|
| Complexity | Low | High (conceptually) | Medium |
| Flexibility | Low | **Maximum** | Medium (JSON rules) |
| State change cost | üî¥ Code changes likely | üü¢ **SQL only ‚Äî always** | üü° SQL for single type, code for multi |
| Code reuse | None | **Total** (shared engine) | High (patterns) |
| New entity cost | New engine + tables + service | **Zero code ‚Äî SQL only** | New adapter + service |
| Tenant isolation | ‚ùå Not possible | ‚úÖ `EntityType` composite key | ‚ùå Not possible |
| Dynamic transition rules | ‚ùå Not supported | ‚úÖ JSON `Rules` column + evaluator | ‚úÖ JSON `Rules` column + evaluator |
| `DataProcessResult` | ‚ùå Throws exceptions | ‚úÖ Structured results + metadata | ‚úÖ Structured results + metadata |
| Dynamic entity metadata | ‚ùå Fixed schema | ‚úÖ `Metadata` JSON column | ‚úÖ `Metadata` JSON column |
| Best for | Single microservice | Platform / monolith core | Enterprise microservice |

### The 4 Key Architectural Differences

These are the structural decisions that determine each approach's flexibility:

| Feature | A | D | B |
|---------|---|---|---|
| **EntityType scoping** | ‚ùå Global statuses | ‚ùå Global statuses | ‚úÖ Per-entity-type |
| **Dynamic transition Rules** | ‚ùå None | ‚úÖ `Dictionary<string,object>` | ‚úÖ `Dictionary<string,object>` + evaluation |
| **DataProcessResult** | ‚ùå Throws exceptions | ‚úÖ Yes | ‚úÖ Yes + `WithMeta` chain |
| **Transaction Metadata** | ‚ùå Fixed schema | ‚úÖ Dynamic dict | ‚úÖ Dynamic dict |

B's `EntityType` field is the critical differentiator. It turns the state machine from a **single hardwired graph** into a **registry of unlimited graphs**, all managed via data. D is the pragmatic choice for a single-entity system that may grow; B is the correct choice if multi-entity or multi-tenant workflows are even remotely likely.

---

## üîÆ Extension Roadmap ‚Äî From "Transaction Engine" to "Workflow Platform"

Each approach shipped here solves the assignment. The extensions below are **not implemented** ‚Äî they are architectural suggestions showing how the V17 patterns would scale to real-world requirements. They demonstrate **why** the pattern choices matter: what costs one line in Approach B costs a full rebuild in Approach A.

> **Execution strategy:** The `agent.md` file contains ready-to-use AI prompts (for Copilot, Claude, Cursor) that implement each extension following V17 patterns. The `.ai-config/v17-skill-library.md` file serves as the "rule book" ‚Äî upload it before any AI session to enforce correct patterns.

### The V17 Architecture Strategy

Before implementing, understand **why** each extension maps to a specific V17 skill:

| Extension | V17 Skill | Architectural Principle |
|-----------|-----------|----------------------|
| Configurable Tasks | Skill 05 (Database Fabric) | Don't add columns ‚Äî use a JSON data column |
| Multi-Project Workflows | Skill 08 (Flow Definition) | Add a scope discriminator, not new tables |
| Role-Based Permissions | Skill 02 (Object Processor) | Permissions are JSON rules, not `if` statements |
| SSO / Flexible Auth | Skill 15 (API Gateway) | Auth config lives in `appsettings.json`, not in code |

### Extension 1: Configurable Tasks (JSON Data Columns)

**Problem:** Different departments want different fields ‚Äî Sales needs "Priority", Finance needs "DueDate", Support needs "CustomerSegment". Adding columns for each is unsustainable.

**V17 Pattern:** Skill 05 (Database Fabric) ‚Äî add a `Dictionary<string, object> Data` property stored as a JSON column via EF Core `ValueConversion`. No schema changes needed per field.

```csharp
// Example of how the API would look after implementing this extension:
POST /transactions
{ "amount": 500, "currency": "USD", "metadata": { "priority": "high", "department": "sales" } }
```

| Approach | Effort | How |
|----------|--------|-----|
| A | üü° Medium | Add JSON column + ValueConverter to Transaction entity |
| B | ‚úÖ Already done | `Metadata` dictionary already exists on Transaction |
| D | ‚úÖ Already done | `Metadata` dictionary already exists on Transaction |

> **AI Prompt (from agent.md):** *"Add a `JsonDocument` property named `Data` to the Transaction entity. Configure EF Core `ValueConversion` to store as JSON string. Update the DTO to accept `Dictionary<string, object> Data`. Constraint: Do not add specific columns like 'DueDate' to the SQL table."*

### Extension 2: Multi-Project Workflows

**Problem:** Project A needs "ToDo ‚Üí Done" while Project B needs "Draft ‚Üí Review ‚Üí Publish". One workflow doesn't fit all.

**V17 Pattern:** Skill 08 (Flow Definition) ‚Äî add a nullable `ProjectId` foreign key to `WorkflowStatus` and `WorkflowTransition`. Project-specific transitions override global defaults. The repository implements fallback logic: look for project-specific transitions first, fall back to global if none found.

```sql
-- Project-scoped workflow (no code changes in B)
INSERT INTO WorkflowStatuses (EntityType, Name, IsInitial, ProjectId)
VALUES ('task', 'DRAFT', 1, @projectBId);
```

| Approach | Effort | How |
|----------|--------|-----|
| A | üî¥ High | New tables, new engine, new service ‚Äî fundamental restructuring |
| B | üü¢ Low | Add `ProjectId` column + repository fallback logic. `EntityType` scoping already provides the foundation |
| D | üü° Medium | Add `ProjectId` + update repository queries + update engine interface |

> **AI Prompt (from agent.md):** *"Create a `Project` entity (Id, Name, Key). Update `WorkflowStatus` and `WorkflowTransition` to include nullable `ProjectId` FK. Update the repository: when loading transitions for Project X, look for specific transitions first; fallback to global if none found. Constraint: The WorkflowEngine interface must not change."*

### Extension 3: Role-Based Transition Permissions

**Problem:** Only managers should be able to approve transitions from "Validated" to "Processing". Currently anyone can.

**V17 Pattern:** Skill 02 (Object Processor) ‚Äî permissions are **data, not code**. Store `{ "allowedRoles": ["Manager", "Admin"] }` in the transition's `Rules` JSON column. The generic `RuleEvaluator` checks it. The API Gateway (Skill 15) extracts user claims from the JWT token and passes them into the engine's `context` dictionary. The engine never imports auth libraries ‚Äî it just reads keys from the context.

```json
// WorkflowTransitions.Rules column:
{ "allowedRoles": ["Manager", "Admin"], "maxRetries": 3 }
```

```csharp
// Controller extracts claims and passes to engine ‚Äî engine stays auth-free:
var userRoles = HttpContext.User.Claims.Where(c => c.Type == ClaimTypes.Role).Select(c => c.Value).ToList();
var context = new Dictionary<string, object> { ["UserRoles"] = userRoles };
await _engine.TryTransitionAsync(statusId, target, context: context);
```

| Approach | Effort | How |
|----------|--------|-----|
| A | üî¥ High | No rules engine ‚Äî hardcode `if (role == "Admin")` in controller, doesn't scale |
| B | üü¢ Low | Add `allowedRoles` key to `EvaluateTransitionRules` ‚Äî ~10 lines of code |
| D | üü¢ Low | Same as B ‚Äî rules engine already exists in `EvaluateTransitionRules` |

> **AI Prompt (from agent.md):** *"Permissions are defined in the database by adding `{ 'allowedRoles': ['Manager', 'Admin'] }` to WorkflowTransition.Rules JSON. Extend `EvaluateTransitionRules` to check if the context dictionary contains a `UserRoles` list and validate against the rule. In the controller, extract roles from `HttpContext.User` claims and pass via context. Do NOT hardcode roles in C#."*

### Extension 4: SSO / Flexible Authentication

**Problem:** Customer A uses Azure AD, Customer B uses Okta, Customer C uses Google. Need to support all without code changes.

**V17 Pattern:** Skill 15 (API Gateway) ‚Äî auth configuration lives in `appsettings.json`, not in code. A Strategy Pattern reads `Authority`, `ClientId`, `Audience` from config and wires up `JwtBearer` automatically.

```json
// appsettings.json ‚Äî swap SSO provider with zero code:
"Auth": { "Authority": "https://login.microsoftonline.com/...", "ClientId": "...", "Audience": "..." }
```

**Key constraint:** The Domain project never depends on auth libraries. Authentication is purely an API/Infrastructure concern.

| Approach | Effort | How |
|----------|--------|-----|
| A | üü° Medium | Add `AddFlexibleAuth()` extension in API project |
| B | üü° Medium | Same ‚Äî auth is orthogonal to the engine |
| D | üü° Medium | Same ‚Äî auth is orthogonal to the engine |

> **AI Prompt (from agent.md):** *"Implement a Strategy Pattern for auth in `Program.cs`. Create `AuthSettings` in `appsettings.json` with Authority, ClientId, Audience. Create an `AddFlexibleAuth(configuration)` extension that reads settings and configures JwtBearer. Constraint: The Domain project must NOT depend on any Auth libraries."*

### Extension Summary

| Extension | V17 Skill | A | B | D |
|-----------|-----------|---|---|---|
| Configurable tasks (JSON fields) | Skill 05 | üü° Add column | ‚úÖ Already built | ‚úÖ Already built |
| Multi-project workflows | Skill 08 | üî¥ Rebuild | üü¢ Add scope column | üü° Add scope + refactor |
| Role-based permissions | Skill 02 | üî¥ Hardcode | üü¢ Add JSON rule key | üü¢ Add JSON rule key |
| SSO / flexible auth | Skill 15 | üü° Config extension | üü° Config extension | üü° Config extension |

### How to Execute These Extensions

1. **Prepare:** Save the `.ai-config/v17-skill-library.md` file in your repo (already included).
2. **Context:** Start a new chat with Copilot/Claude/Cursor. Attach the library file + `CLAUDE.md`.
3. **Execute:** Paste the prompts from `agent.md` one by one:
   - Start with Extension 1 (Configurable Tasks) ‚Äî updates the core entity
   - Move to Extension 2 (Multi-Project) ‚Äî updates the schema and scoping
   - Implement Extension 3 (Permissions) ‚Äî leverages the JSON rules
   - Finish with Extension 4 (SSO) ‚Äî secures the API

> **Note:** Each extension builds on the previous. Extension 2 benefits from Extension 1's JSON column pattern. Extension 3 requires the `Rules` JSON column that B and D already have. Extension 4 is orthogonal and can be done at any point.

---

## üß† AI Agent Configuration

Each approach ships with pre-configured AI agent context files:

| Agent | Config File | Purpose |
|-------|-------------|---------|
| GitHub Copilot | `.github/copilot-instructions.md` | Inline suggestions following V17 patterns |
| Claude Code | `CLAUDE.md` | Project-aware coding with architecture rules |
| General / Any AI | `.ai-config/project-architecture.md` | Philosophy + pattern reference |
| Skill Library | `.ai-config/v17-skill-library.md` | V17 skill ‚Üí actual file mapping |
| Extension Prompts | `agent.md` | Copy-paste prompts for implementing Extensions 1‚Äì4 |

The `.ai-config/` folder contains prompt-engineered context so AI agents extend the project using the correct patterns (DataProcessResult, JSON rules, generic engines) instead of writing legacy code.

### Using the Skill Library with AI Agents

The `v17-skill-library.md` file acts as a rule book that enforces 5 core skills:

| Skill | Rule | AI Must... |
|-------|------|-----------|
| **Skill 01** (Core Interfaces) | All business logic returns `DataProcessResult<T>` | Never throw exceptions for logical failures |
| **Skill 02** (Object Processor) | Business rules are JSON configuration, not code | Use `RuleEvaluator` to parse `allowedRoles`, `minAmount`, `maxRetries` |
| **Skill 05** (Database Fabric) | Dynamic requirements use JSON columns | Never alter schema for new field requirements |
| **Skill 08** (Flow Definition) | Workflows are defined by data, not code | Scope by `ProjectId` or `EntityType`, not by new classes |
| **Skill 15** (API Gateway) | API layer translates, never contains logic | Extract claims from tokens ‚Üí inject into engine context |

**Workflow:** Upload `v17-skill-library.md` + `CLAUDE.md` at the start of any AI session ‚Üí paste prompts from `agent.md` ‚Üí AI follows the rules instead of writing legacy patterns.
