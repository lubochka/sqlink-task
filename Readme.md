# Transaction Workflow Engine ‚Äî Home Assignment

> **3 approaches** to the same backend assignment, each demonstrating a different level of architectural maturity using the XIIGen V17 "Freedom Machine" skill set.

---

## üìÇ Repository Structure

```text
sqlink-task/
‚îú‚îÄ‚îÄ TransactionWorkflow_ApproachA.zip    # Vanilla .NET Clean Architecture
‚îú‚îÄ‚îÄ TransactionWorkflow_ApproachB.zip    # DNA-Infused Multi-Tenant Engine
‚îú‚îÄ‚îÄ TransactionWorkflow_ApproachD.zip    # Strategic Hybrid (‚≠ê Recommended)
‚îú‚îÄ‚îÄ buildAll.ps1                         # One-click extract + build all 3
‚îú‚îÄ‚îÄ testAll.ps1                          # Full integration test suite v2 (Docker + API + auto-fixes)
‚îú‚îÄ‚îÄ Backend_Home_Assignment.docx         # Original assignment brief
‚îú‚îÄ‚îÄ Readme.md                            # ‚Üê You are here
‚îÇ
‚îú‚îÄ‚îÄ approach_analysis.md                 # Deep analysis of all 4 approaches (A, B, C, D)
‚îú‚îÄ‚îÄ approach_analysis.jsx                # Interactive React comparison UI
‚îú‚îÄ‚îÄ approaches_comparison.md             # Side-by-side flow comparison (A vs B vs D)
‚îú‚îÄ‚îÄ agent.md                             # V17 skill prompt library for AI-assisted extensions
‚îú‚îÄ‚îÄ plan_diagram.mermaid                 # Visual phase dependency graph
‚îÇ
‚îú‚îÄ‚îÄ FINAL_STATE.md                       # Phase 1‚Äì4 completion tracking
‚îú‚îÄ‚îÄ IMPROVEMENT_PLAN.md                  # Phase 5‚Äì7 (R1‚ÄìR7) improvement requirements
‚îú‚îÄ‚îÄ INTEGRATION_FINAL_STATE.md           # V17 skill integration final status
‚îî‚îÄ‚îÄ TEST_REPORT.md                       # Auto-generated by testAll.ps1
```

---

## üöÄ Quick Start ‚Äî Build & Run All 3

### Prerequisites
- .NET 8 SDK
- Docker & Docker Compose (for running)
- PowerShell (for `buildAll.ps1`)

### One Command
```powershell
.\buildAll.ps1
```

This script extracts all 3 zips, applies known patches, and builds each solution. After build succeeds, run any approach:

```bash
cd TransactionWorkflow_ApproachD     # or A, or B
./start.sh                            # Linux / Mac / WSL
# ‚Äî or ‚Äî
docker-compose up --build -d          # Windows native
# ‚Üí Swagger UI: http://localhost:5000/swagger
# ‚Üí Health Check: http://localhost:5000/health
```

### Run Tests
```bash
# Unit tests (no Docker required)
cd TransactionWorkflow_ApproachD
dotnet test

# Full integration tests ‚Äî all 3 approaches via Docker (from root)
.\testAll.ps1
```

---

## üèóÔ∏è The 3 Approaches

### Approach A ‚Äî "Textbook Clean Architecture" (Vanilla)

The safe, expected solution. Classical .NET Clean Architecture with EF Core, domain exceptions, and service layer. No V17 patterns.

- **Engine:** Transaction-specific (`WorkflowEngine` knows about transactions)
- **Error handling:** Domain exceptions ‚Üí ProblemDetails middleware
- **Extensibility:** Adding "Orders" requires new code (engine + tables + service)
- **Best for:** Evaluators who want to see exactly what they asked for

### Approach B ‚Äî "DNA-Infused Multi-Tenant Engine"

The platform play. Introduces an `EntityType` discriminator ‚Äî one set of database tables manages workflows for **any entity type** simultaneously.

- **Engine:** Entity-agnostic (`TryTransitionAsync("transaction", ...)`)
- **Error handling:** `DataProcessResult<T>` ‚Üí `ResultMapper` ‚Üí ProblemDetails
- **Extensibility:** Adding "Orders" = SQL INSERT only, **zero code changes**
- **Best for:** Evaluators who value architectural vision and platform thinking

### Approach D ‚Äî "Strategic Hybrid" ‚≠ê Recommended

The sweet spot. Looks like a standard .NET project on the outside, but uses Freedom Machine patterns on the inside. 80% of B's benefits with 20% of the complexity.

- **Engine:** Generic (depends only on `IWorkflowRepository`, not entity repos)
- **Error handling:** `DataProcessResult<T>` ‚Üí `ResultMapper` ‚Üí ProblemDetails
- **Extensibility:** JSON rules in DB for dynamic business logic, new adapter code for new entities
- **Best for:** Evaluators who want clean code PLUS evidence of deeper thinking

---

## üß™ The "Freedom Machine" Test

> *"Can a business user change the workflow without a developer?"*

| Capability | A | B | D |
|------------|---|---|---|
| Add new status | ‚úÖ SQL INSERT | ‚úÖ SQL INSERT (scoped by EntityType) | ‚úÖ SQL INSERT |
| Add new entity type (e.g. Orders) | ‚ùå New code | ‚úÖ **SQL only ‚Äî zero code** | ‚ùå New adapter code |
| Add business rule (e.g. maxRetries) | ‚ùå C# change | ‚úÖ JSON column + generic evaluator | ‚úÖ JSON column + generic evaluator |
| Swap database provider | ‚ùå Coupled to EF | üü° Behind interfaces | üü° Behind interfaces |

---

## üõ†Ô∏è V17 Skill Set Integration

Each approach maps to the XIIGen V17 skill library at a different depth:

| V17 Skill | Purpose | A | B | D |
|-----------|---------|---|---|---|
| **Skill 01** ‚Äî Core Interfaces / DataProcessResult | Structured errors, no exceptions | ‚ùå Exceptions | ‚úÖ Full | ‚úÖ Full |
| **Skill 02** ‚Äî Object Processor / JSON Rules | Dynamic business rules as data | ‚ùå | ‚úÖ Full | ‚úÖ Full |
| **Skill 05** ‚Äî Database Fabric | Generic data access patterns | ‚úÖ EF Core | ‚úÖ EF Core + JSON | ‚úÖ EF Core + JSON |
| **Skill 08** ‚Äî Flow Definition | Workflow as data, not code | ‚úÖ DB rows | ‚úÖ EntityType-scoped | ‚úÖ DB rows |
| **Skill 09** ‚Äî Flow Orchestrator | State machine engine | ‚úÖ Specific | ‚úÖ Generic (multi-tenant) | ‚úÖ Generic (single-tenant) |
| **Skill 15** ‚Äî API Gateway | HTTP ‚Üî domain mapping | ‚úÖ Middleware | ‚úÖ ResultMapper | ‚úÖ ResultMapper |
| **Skill 29** ‚Äî Testing | Automated quality assurance | ‚úÖ xUnit | ‚úÖ xUnit + isolation | ‚úÖ xUnit |
| **Skill 45** ‚Äî Design Patterns | Decorator, Adapter, Strategy | ‚úÖ Decorator | ‚úÖ All three | ‚úÖ All three |

### The "Freedom Machine" Philosophy

The XIIGen V17 skill set is built around one principle: **if a business user might want to change it, it must be data, not code.**

- **MACHINE** = generic logic that never changes (the workflow engine, the result mapper, the repository interfaces)
- **FREEDOM** = configuration that business users control (statuses, transitions, rules ‚Äî all in the database)

Approach A puts everything in the MACHINE. Approach B maximizes FREEDOM. Approach D finds the strategic balance.

---

## üì° API Endpoints (All Approaches)

### Core ‚Äî Transactions

| Method | Endpoint | Description |
|--------|----------|-------------|
| `POST` | `/transactions` | Create a new transaction |
| `GET` | `/transactions/{id}` | Get transaction by ID |
| `POST` | `/transactions/{id}/transition` | Transition to a new status |
| `GET` | `/transactions/{id}/available-transitions` | List valid next statuses |
| `GET` | `/transactions/{id}/history` | Status change audit trail |

### Bonus ‚Äî Admin Workflow Management

| Method | Endpoint | Description |
|--------|----------|-------------|
| `GET` | `/admin/workflow/statuses` | List all workflow statuses |
| `POST` | `/admin/workflow/statuses` | Add a new status |
| `GET` | `/admin/workflow/transitions` | List all transitions |
| `POST` | `/admin/workflow/transitions` | Add a new transition |
| `GET` | `/admin/workflow/visualize` | Mermaid.js workflow diagram |
| `GET` | `/health` | Health check with DB connectivity |

### Seeded Workflow
```
CREATED ‚Üí VALIDATED ‚Üí PROCESSING ‚Üí COMPLETED
                               ‚Üò FAILED ‚Üí VALIDATED (retry)
```

---

## üìñ Documentation Map

| Document | What It Covers |
|----------|---------------|
| [`approach_analysis.md`](approach_analysis.md) | Deep dive into all 4 approaches (A, B, C, D) with phase plans, V17 skill mapping, positive/negative examples, and recovery strategy |
| [`approaches_comparison.md`](approaches_comparison.md) | Side-by-side flow comparison: how Create Transaction and Execute Transition work differently in A vs B vs D |
| [`agent.md`](agent.md) | V17 prompt library: copy-paste prompts for AI agents to implement configurable tasks, multi-project workflows, permissions, and SSO |
| [`approach_analysis.jsx`](approach_analysis.jsx) | Interactive React component for visual approach comparison |
| [`plan_diagram.mermaid`](plan_diagram.mermaid) | Phase dependency graph (DevOps ‚Üí Validation ‚Üí API Quality ‚Üí Documentation) |
| [`IMPROVEMENT_PLAN.md`](IMPROVEMENT_PLAN.md) | Requirements R1‚ÄìR7: engine purity, exception middleware, health checks, security, dependency fixes |
| [`FINAL_STATE.md`](FINAL_STATE.md) | Phase 1‚Äì4 completion: Docker healthchecks, FluentValidation, ProblemDetails, Mermaid visualization |
| [`INTEGRATION_FINAL_STATE.md`](INTEGRATION_FINAL_STATE.md) | V17 integration completion: AI configs, skill maps, code improvements across all 3 approaches |
| [`TEST_REPORT.md`](TEST_REPORT.md) | Auto-generated test results from `testAll.ps1` (33 tests across 3 approaches) |

---

## üî® buildAll.ps1 ‚Äî What It Does

```
1. Extracts all 3 zips into folders
2. Patches B & D: moves a `using` statement from mid-file to top (cosmetic fix)
3. Runs `dotnet restore` + `dotnet build` for each approach
4. Reports build status with error highlighting
```

> **Note:** `testAll.ps1` applies an additional runtime fix: `Migrate()` ‚Üí `EnsureCreated()` in `Program.cs` because no EF migration files exist in the zips. The `buildAll.ps1` only handles compilation ‚Äî the migration fix is only needed when actually running the containers.

Expected output:
```
=== TransactionWorkflow_ApproachA ===
Build succeeded.    0 Warning(s)    0 Error(s)
BUILD OK

=== TransactionWorkflow_ApproachB ===
Build succeeded.    0 Warning(s)    0 Error(s)
BUILD OK

=== TransactionWorkflow_ApproachD ===
Build succeeded.    0 Warning(s)    0 Error(s)
BUILD OK
```

---

## üß™ testAll.ps1 ‚Äî Full Integration Test Suite (v2)

Runs Docker-based end-to-end tests against all 3 approaches sequentially. For each approach it extracts fresh from zip, applies automatic fixes, spins up containers, waits for the API, runs 11 tests, tears down, and moves to the next.

### Usage
```powershell
.\testAll.ps1
```

### Automatic Fixes Applied Before Testing

The script detects and patches known issues before building each approach:

| Fix | What | Why |
|-----|------|-----|
| `Migrate()` ‚Üí `EnsureCreated()` | Replaces EF migration call in `Program.cs` | No EF migration files exist ‚Äî `EnsureCreated()` builds schema from model |
| Misplaced `using` | Moves `using TransactionWorkflow.API.Middleware;` to top of file (B, D) | Prevents compilation error |
| Entity-type routes | Uses `/admin/workflow/transaction/` for Approach B | B's multi-tenant admin routes are scoped by entity type |

### What It Tests

| # | Test | Category | Validates |
|---|------|----------|-----------|
| T1 | Create Transaction | Happy Path | `POST /transactions` returns ID + CREATED status |
| T2 | Get Transaction | Happy Path | `GET /transactions/{id}` returns correct status |
| T3 | Available Transitions | Happy Path | CREATED ‚Üí VALIDATED is listed |
| T4 | Full Workflow | Happy Path | CREATED ‚Üí VALIDATED ‚Üí PROCESSING ‚Üí COMPLETED |
| T5 | Transaction History | Happy Path | At least 3 history entries after full workflow |
| T6 | Bad Input ‚Üí 400 | Error Path | Negative amount + invalid currency rejected |
| T7 | Invalid Transition ‚Üí 400 | Error Path | CREATED ‚Üí COMPLETED skipped, returns 400 |
| T8 | Not Found ‚Üí 404 | Error Path | Non-existent transaction ID returns 404 |
| T9 | Workflow Visualization | Features | `GET /admin/workflow/visualize` returns Mermaid graph |
| T10 | Admin: Get Statuses | Features | At least 4 seeded statuses returned |
| T11 | Admin: Get Transitions | Features | At least 4 seeded transitions returned |

### Test Flow Per Approach
```
Extract zip ‚Üí Fix Migrate/using/routes ‚Üí docker-compose up ‚Üí Wait for API (90s max)
‚Üí Run 11 API tests (with error body capture) ‚Üí docker-compose down ‚Üí Next approach
```

### Output
```
============================================================
  FINAL REPORT
============================================================

  Approach A (Vanilla)
  --------------------------------------------------
    [PASS] Docker Build
    [PASS] API Startup
    [PASS] Create Transaction
    ...

  Approach B (Multi-Tenant DNA)
  --------------------------------------------------
    [PASS] Docker Build
    ...

  Approach D (Strategic Hybrid)
  --------------------------------------------------
    [PASS] Docker Build
    ...

  TOTAL: 33 passed, 0 failed  |  Time: 8.2 min
============================================================
```

A `TEST_REPORT.md` is auto-generated with the full results table, fix log, and per-test detail column.

---

## üî¨ Deep Dive: How the Approaches Differ

The three approaches solve the same API contract but diverge fundamentally in how the **engine** and **database** work together.

### The Engine Signature ‚Äî The Key Differentiator

**Approach A** ‚Äî the engine knows it's dealing with a Transaction:
```csharp
public async Task TransitionAsync(Transaction transaction, string targetStatus)
{
    // Queries specific "TransactionTransitions" table
}
```

**Approach D** ‚Äî the engine is generic in behavior but still single-tenant:
```csharp
public async Task<DataProcessResult<TransitionOutcome>> TryTransitionAsync(
    int currentStatusId, string targetStatus, int priorTransitionCount, ...)
{
    // Queries "WorkflowTransitions" table (single scope)
}
```

**Approach B** ‚Äî the engine doesn't know what a "Transaction" is:
```csharp
public async Task<DataProcessResult<TransitionOutcome>> TryTransitionAsync(
    string entityType,           // ‚Üê THE KEY DIFFERENTIATOR
    string currentStatusName, int currentStatusId, string targetStatusName, ...)
{
    // Queries SHARED table filtered by EntityType
    var allowed = await _repo.GetAllowedTransitionsAsync(entityType, currentStatusId);
}
```

### Flow Comparison: Creating a Transaction

| Step | Approach A | Approach B | Why B differs |
|------|-----------|-----------|---------------|
| Service call | `_engine.GetInitialStatusAsync()` | `_engine.GetInitialStatusAsync("transaction")` | B needs the `entityType` to find the right workflow in shared tables |
| DB query | `WHERE IsInitial = 1` | `WHERE IsInitial = 1 AND EntityType = 'transaction'` | Same table holds initial states for Orders, Tickets, etc. |
| Result | `WorkflowStatus` | `WorkflowStatus` | Same output, different source scope |

### Flow Comparison: Executing a Transition

| Step | Approach A | Approach B | Architectural shift |
|------|-----------|-----------|-------------------|
| Adapter | `engine.TransitionAsync(txn, target)` | `engine.TryTransitionAsync("transaction", ...)` | B's `TransactionService` acts as an Adapter from specific ‚Üí generic |
| Isolation | Checks `FromId` / `ToId` | Checks `FromId` / `ToId` **AND** `EntityType` | B ensures a Transaction can't use an Order's transition rule |
| Extensibility | New entity = new engine + tables + service | New entity = **SQL INSERT only** | B achieves the Freedom Machine ideal |
| DB design | FK to `TransactionStatus` | FK to `WorkflowStatus` + composite index `(EntityType, Name)` | Uniqueness within scope, not globally |

### Summary of Tradeoffs

| Dimension | A (Vanilla) | B (Multi-Tenant) | D (Hybrid) |
|-----------|-------------|-------------------|------------|
| Complexity | Low | High (conceptually) | Medium |
| Flexibility | Low | **Maximum** | Medium (JSON rules) |
| Code reuse | None | **Total** (shared engine) | High (patterns) |
| New entity cost | New engine + tables + service | **Zero code ‚Äî SQL only** | New adapter + service |
| Best for | Single microservice | Platform / monolith core | Enterprise microservice |

---

## üîÆ Extension Roadmap ‚Äî From "Transaction Engine" to "Workflow Platform"

Each approach shipped here solves the assignment. The extensions below are **not implemented** ‚Äî they are architectural suggestions showing how the V17 patterns would scale to real-world requirements. They demonstrate **why** the pattern choices matter: what costs one line in Approach B costs a full rebuild in Approach A.

### Extension 1: Configurable Tasks (JSON Data Columns)

**Problem:** Different departments want different fields ‚Äî Sales needs "Priority", Finance needs "DueDate", Support needs "CustomerSegment". Adding columns for each is unsustainable.

**V17 Pattern:** Skill 05 (Database Fabric) ‚Äî add a `Dictionary<string, object> Metadata` property stored as a JSON column via EF Core `ValueConversion`. No schema changes needed per field.

```csharp
// Example of how the API would look after implementing this extension:
POST /transactions
{ "amount": 500, "currency": "USD", "metadata": { "priority": "high", "department": "sales" } }
```

| Approach | Effort | How |
|----------|--------|-----|
| A | üü° Medium | Add JSON column + ValueConverter to Transaction entity |
| B | üü¢ Low | `EntityType` scoping already supports diverse data shapes ‚Äî add JSON column |
| D | üü¢ Low | `Metadata` dictionary pattern already on Transaction ‚Äî extend it |

### Extension 2: Multi-Project Workflows

**Problem:** Project A needs "ToDo ‚Üí Done" while Project B needs "Draft ‚Üí Review ‚Üí Publish". One workflow doesn't fit all.

**V17 Pattern:** Skill 08 (Flow Definition) ‚Äî add a nullable `ProjectId` foreign key to `WorkflowStatus` and `WorkflowTransition`. Project-specific transitions override global defaults.

```sql
-- Project-scoped workflow (no code changes in B)
INSERT INTO WorkflowStatuses (EntityType, Name, IsInitial, ProjectId)
VALUES ('task', 'DRAFT', 1, @projectBId);
```

| Approach | Effort | How |
|----------|--------|-----|
| A | üî¥ High | New tables, new engine, new service |
| B | üü¢ Low | Add `ProjectId` column + repository fallback logic |
| D | üü° Medium | Add `ProjectId` + update repository queries |

### Extension 3: Role-Based Transition Permissions

**Problem:** Only managers should be able to approve transitions from "Validated" to "Processing". Currently anyone can.

**V17 Pattern:** Skill 02 (Object Processor) ‚Äî permissions are **data, not code**. Store `{ "allowedRoles": ["Manager", "Admin"] }` in the transition's `Rules` JSON column. The generic `RuleEvaluator` checks it.

```json
// WorkflowTransitions.Rules column:
{ "allowedRoles": ["Manager", "Admin"], "maxRetries": 3 }
```

The API Gateway (Skill 15) extracts user claims from the JWT token and passes them into the engine's `context` dictionary. The engine never imports auth libraries.

| Approach | Effort | How |
|----------|--------|-----|
| A | üî¥ High | Hardcoded `if (role == "Admin")` in controller ‚Äî not scalable |
| B | üü¢ Low | Add `allowedRoles` key to `EvaluateTransitionRules` ‚Äî 10 lines |
| D | üü¢ Low | Same as B ‚Äî rules engine already exists |

### Extension 4: SSO / Flexible Authentication

**Problem:** Customer A uses Azure AD, Customer B uses Okta, Customer C uses Google. Need to support all without code changes.

**V17 Pattern:** Skill 15 (API Gateway) ‚Äî auth configuration lives in `appsettings.json`, not in code. A Strategy Pattern reads `Authority`, `ClientId`, `Audience` from config and wires up `JwtBearer` automatically.

```json
// appsettings.json ‚Äî swap SSO provider with zero code:
"Auth": { "Authority": "https://login.microsoftonline.com/...", "ClientId": "...", "Audience": "..." }
```

**Key constraint:** The Domain project never depends on auth libraries. Authentication is purely an API/Infrastructure concern.

| Approach | Effort | How |
|----------|--------|-----|
| A | üü° Medium | Add `AddFlexibleAuth()` extension in API project |
| B | üü° Medium | Same ‚Äî auth is orthogonal to the engine |
| D | üü° Medium | Same ‚Äî auth is orthogonal to the engine |

### Extension Summary (Estimated Effort If Implemented)

| Extension | V17 Skill | A | B | D |
|-----------|-----------|---|---|---|
| Configurable tasks (JSON fields) | Skill 05 | üü° Add column | ‚úÖ Pattern ready | ‚úÖ Pattern ready |
| Multi-project workflows | Skill 08 | üî¥ Rebuild | üü¢ Add scope column | üü° Add scope column |
| Role-based permissions | Skill 02 | üî¥ Hardcode | üü¢ Add JSON rule key | üü¢ Add JSON rule key |
| SSO / flexible auth | Skill 15 | üü° Config extension | üü° Config extension | üü° Config extension |

> **Note:** The `agent.md` file contains ready-to-use AI prompts engineered to implement each extension following V17 patterns. Attach it to Copilot or Claude and paste the prompts.

---

## üß† AI Agent Configuration

Each approach ships with pre-configured AI agent context files:

| Agent | Config File | Purpose |
|-------|-------------|---------|
| GitHub Copilot | `.github/copilot-instructions.md` | Inline suggestions following V17 patterns |
| Claude Code | `CLAUDE.md` | Project-aware coding with architecture rules |
| General / Any AI | `.ai-config/project-architecture.md` | Philosophy + pattern reference |
| Skill Library | `.ai-config/v17-skill-map.md` | V17 skill ‚Üí actual file mapping |

The `.ai-config/` folder contains prompt-engineered context so AI agents extend the project using the correct patterns (DataProcessResult, JSON rules, generic engines) instead of writing legacy code.
