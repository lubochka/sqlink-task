# Transaction Workflow Engine â€” Home Assignment

> **3 approaches** to the same backend assignment, each demonstrating a different level of architectural maturity using the XIIGen V17 "Freedom Machine" skill set.

---

## ğŸ“‚ Repository Structure

```text
sqlink-task/
â”œâ”€â”€ TransactionWorkflow_ApproachA.zip    # Vanilla .NET Clean Architecture
â”œâ”€â”€ TransactionWorkflow_ApproachB.zip    # DNA-Infused Multi-Tenant Engine
â”œâ”€â”€ TransactionWorkflow_ApproachD.zip    # Strategic Hybrid (â­ Recommended)
â”œâ”€â”€ buildAll.ps1                         # One-click extract + build all 3
â”œâ”€â”€ testAll.ps1                          # Full integration test suite v2 (Docker + API + auto-fixes)
â”œâ”€â”€ Backend_Home_Assignment.docx         # Original assignment brief
â”œâ”€â”€ Readme.md                            # â† You are here
â”‚
â”œâ”€â”€ approach_analysis.md                 # Deep analysis of all 4 approaches (A, B, C, D)
â”œâ”€â”€ approach_analysis.jsx                # Interactive React comparison UI
â”œâ”€â”€ approaches_comparison.md             # Side-by-side flow comparison (A vs B vs D)
â”œâ”€â”€ cto_analysis.jsx                     # Interactive architectural decision dashboard
â”œâ”€â”€ agent.md                             # V17 skill prompt library for AI-assisted extensions
â”œâ”€â”€ .ai-config/v17-skill-library.md      # Rule book for AI agents (upload before any session)
â”œâ”€â”€ plan_diagram.mermaid                 # Visual phase dependency graph
â”‚
â”œâ”€â”€ FINAL_STATE.md                       # Phase 1â€“4 completion tracking
â”œâ”€â”€ IMPROVEMENT_PLAN.md                  # Phase 5â€“7 (R1â€“R7) improvement requirements
â”œâ”€â”€ INTEGRATION_FINAL_STATE.md           # V17 skill integration final status
â””â”€â”€ TEST_REPORT.md                       # Auto-generated by testAll.ps1
```

---

## ğŸš€ Quick Start â€” Build & Run All 3

### Prerequisites
- .NET 8 SDK
- Docker & Docker Compose (for running)
- PowerShell (for `buildAll.ps1`)

### One Command
```powershell
.\buildAll.ps1
```

This script extracts all 3 zips, applies known patches, and builds each solution. After build succeeds, run any approach:

```bash
cd TransactionWorkflow_ApproachD     # or A, or B
./start.sh                            # Linux / Mac / WSL
# â€” or â€”
docker-compose up --build -d          # Windows native
# â†’ Swagger UI: http://localhost:5000/swagger
# â†’ Health Check: http://localhost:5000/health
```

### Run Tests
```bash
# Unit tests (no Docker required)
cd TransactionWorkflow_ApproachD
dotnet test

# Full integration tests â€” all 3 approaches via Docker (from root)
.\testAll.ps1
```

> **âš ï¸ PowerShell Execution Policy Error?** If you see `cannot be loaded... is not digitally signed`, run with bypass:
> ```powershell
> powershell -ExecutionPolicy Bypass -File .\testAll.ps1
> powershell -ExecutionPolicy Bypass -File .\buildAll.ps1
> ```
> Or set it permanently for your user:
> ```powershell
> Set-ExecutionPolicy -Scope CurrentUser -ExecutionPolicy RemoteSigned
> ```

---

## ğŸ—ï¸ The 3 Approaches

### Approach A â€” "Textbook Clean Architecture" (Vanilla)

The safe, expected solution. Classical .NET Clean Architecture with EF Core, domain exceptions, and service layer. No V17 patterns.

- **Engine:** Transaction-specific (`WorkflowEngine` knows about transactions)
- **Error handling:** Domain exceptions â†’ ProblemDetails middleware
- **State flexibility:** Fixed â€” changing state combinations requires code changes
- **Extensibility:** Adding "Orders" requires new code (engine + tables + service)
- **Best for:** Evaluators who want to see exactly what they asked for

### Approach B â€” "DNA-Infused Multi-Tenant Engine" â­ Most Flexible

The platform play. Introduces an `EntityType` discriminator â€” one set of database tables manages workflows for **any entity type** simultaneously. **Easiest to change state combinations later** because the engine is fully data-driven and scoped by entity type.

- **Engine:** Entity-agnostic (`TryTransitionAsync("transaction", ...)`)
- **Error handling:** `DataProcessResult<T>` â†’ `ResultMapper` â†’ ProblemDetails
- **State flexibility:** Maximum â€” add/remove/rewire states and transitions via SQL only, per entity type, even per tenant
- **Extensibility:** Adding "Orders" = SQL INSERT only, **zero code changes**
- **Best for:** Evaluators who value architectural vision and platform thinking

### Approach D â€” "Strategic Hybrid" â­ Recommended Starting Point

The sweet spot. Looks like a standard .NET project on the outside, but uses Freedom Machine patterns on the inside. 80% of B's benefits with 20% of the complexity. Has the JSON `Rules` column and `DataProcessResult`, but lacks B's `EntityType` scoping â€” meaning it handles one workflow type per deployment.

- **Engine:** Generic (depends only on `IWorkflowRepository`, not entity repos)
- **Error handling:** `DataProcessResult<T>` â†’ `ResultMapper` â†’ ProblemDetails
- **State flexibility:** Good â€” add/remove states via SQL, dynamic rules via JSON, but single entity scope
- **Extensibility:** JSON rules in DB for dynamic business logic, new adapter code for new entities
- **Best for:** Evaluators who want clean code PLUS evidence of deeper thinking

### Which Approach Is Easiest to Change State Combinations Later?

**Approach B wins decisively.** The `EntityType` field on `WorkflowStatus` and `WorkflowTransition` turns the state machine from a single hardwired graph into a **registry of unlimited graphs**, all managed via data. The engine code is truly generic â€” it receives `entityType` as a parameter and looks up that type's graph from the database.

D is a solid middle ground â€” it has `DataProcessResult` and `Rules` which make it maintainable. But the moment you need a second workflow type (orders, support tickets), you're essentially rewriting D into B.

A requires code changes for almost any non-trivial state combination change.

---

## ğŸ§ª The "Freedom Machine" Test

> *"Can a business user change the workflow without a developer?"*

### Core Capabilities

| Capability | A | B | D |
|------------|---|---|---|
| Add new status | âœ… SQL INSERT | âœ… SQL INSERT (scoped by EntityType) | âœ… SQL INSERT |
| Add new entity type (e.g. Orders) | âŒ New code | âœ… **SQL only â€” zero code** | âŒ New adapter code |
| Add business rule (e.g. maxRetries) | âŒ C# change | âœ… JSON column + generic evaluator | âœ… JSON column + generic evaluator |
| Swap database provider | âŒ Coupled to EF | ğŸŸ¡ Behind interfaces | ğŸŸ¡ Behind interfaces |

### State Combination Change Scenarios

These scenarios reveal the real cost of changing workflows after deployment:

| Scenario | A | D | B |
|----------|---|---|---|
| **Add "ON_HOLD" between PROCESSING â†’ COMPLETED** | âœ… SQL INSERT | âœ… SQL INSERT + Rules | âœ… SQL INSERT + Rules |
| **Add "order" workflow (PENDING â†’ SHIPPED â†’ DELIVERED)** | ğŸ”´ New engine + tables + service | ğŸ”´ Add EntityType column, refactor engine â€” essentially rewrite into B | ğŸŸ¢ **SQL INSERT only â€” zero code** |
| **Same entity, different workflow per tenant** | ğŸ”´ Impossible | ğŸ”´ Impossible â€” single scope | ğŸŸ¢ Use EntityType as composite key (`"transaction-clientA"` vs `"transaction-clientB"`) |
| **Add role-based permission to a transition** | ğŸ”´ Hardcode `if (role == "Admin")` | ğŸŸ¢ Add JSON rule `{"allowedRoles":["Manager"]}` + 10-line evaluator | ğŸŸ¢ Same as D â€” rules engine exists |
| **Remove "FAILED â†’ VALIDATED" retry path** | âœ… DELETE SQL row | âœ… DELETE SQL row | âœ… DELETE SQL row |

---

## ğŸ› ï¸ V17 Skill Set Integration

Each approach maps to the XIIGen V17 skill library at a different depth:

| V17 Skill | Purpose | A | B | D |
|-----------|---------|---|---|---|
| **Skill 01** â€” Core Interfaces / DataProcessResult | Structured errors, no exceptions | âŒ Exceptions | âœ… Full | âœ… Full |
| **Skill 02** â€” Object Processor / JSON Rules | Dynamic business rules as data | âŒ | âœ… Full | âœ… Full |
| **Skill 05** â€” Database Fabric | Generic data access patterns | âœ… EF Core | âœ… EF Core + JSON | âœ… EF Core + JSON |
| **Skill 08** â€” Flow Definition | Workflow as data, not code | âœ… DB rows | âœ… EntityType-scoped | âœ… DB rows |
| **Skill 09** â€” Flow Orchestrator | State machine engine | âœ… Specific | âœ… Generic (multi-tenant) | âœ… Generic (single-tenant) |
| **Skill 15** â€” API Gateway | HTTP â†” domain mapping | âœ… Middleware | âœ… ResultMapper | âœ… ResultMapper |
| **Skill 29** â€” Testing | Automated quality assurance | âœ… xUnit | âœ… xUnit + isolation | âœ… xUnit |
| **Skill 45** â€” Design Patterns | Decorator, Adapter, Strategy | âœ… Decorator | âœ… All three | âœ… All three |

### The "Freedom Machine" Philosophy

The XIIGen V17 skill set is built around one principle: **if a business user might want to change it, it must be data, not code.**

- **MACHINE** = generic logic that never changes (the workflow engine, the result mapper, the repository interfaces)
- **FREEDOM** = configuration that business users control (statuses, transitions, rules â€” all in the database)

Approach A puts everything in the MACHINE. Approach B maximizes FREEDOM. Approach D finds the strategic balance.

---

## ğŸ“¡ API Endpoints (All Approaches)

### Core â€” Transactions

| Method | Endpoint | Description |
|--------|----------|-------------|
| `POST` | `/transactions` | Create a new transaction |
| `GET` | `/transactions/{id}` | Get transaction by ID |
| `POST` | `/transactions/{id}/transition` | Transition to a new status |
| `GET` | `/transactions/{id}/available-transitions` | List valid next statuses |
| `GET` | `/transactions/{id}/history` | Status change audit trail |

### Bonus â€” Admin Workflow Management

| Method | Endpoint | Description |
|--------|----------|-------------|
| `GET` | `/admin/workflow/statuses` | List all workflow statuses |
| `POST` | `/admin/workflow/statuses` | Add a new status |
| `GET` | `/admin/workflow/transitions` | List all transitions |
| `POST` | `/admin/workflow/transitions` | Add a new transition |
| `GET` | `/admin/workflow/visualize` | Mermaid.js workflow diagram |
| `GET` | `/health` | Health check with DB connectivity |

### Seeded Workflow
```
CREATED â†’ VALIDATED â†’ PROCESSING â†’ COMPLETED
                               â†˜ FAILED â†’ VALIDATED (retry)
```

---

## ğŸ“– Documentation Map

| Document | What It Covers |
|----------|---------------|
| [`approach_analysis.md`](approach_analysis.md) | Deep dive into all 4 approaches (A, B, C, D) with phase plans, V17 skill mapping, positive/negative examples, and recovery strategy |
| [`approaches_comparison.md`](approaches_comparison.md) | Side-by-side flow comparison: how Create Transaction and Execute Transition work differently in A vs B vs D |
| [`cto_analysis.jsx`](cto_analysis.jsx) | Interactive architectural decision dashboard: tradeoff analysis, cost modeling, risk scenarios, team composition guidance |
| [`agent.md`](agent.md) | V17 prompt library: copy-paste prompts for AI agents to implement configurable tasks, multi-project workflows, permissions, and SSO |
| [`approach_analysis.jsx`](approach_analysis.jsx) | Interactive React component for visual approach comparison |
| [`plan_diagram.mermaid`](plan_diagram.mermaid) | Phase dependency graph (DevOps â†’ Validation â†’ API Quality â†’ Documentation) |
| [`IMPROVEMENT_PLAN.md`](IMPROVEMENT_PLAN.md) | Requirements R1â€“R7: engine purity, exception middleware, health checks, security, dependency fixes |
| [`FINAL_STATE.md`](FINAL_STATE.md) | Phase 1â€“4 completion: Docker healthchecks, FluentValidation, ProblemDetails, Mermaid visualization |
| [`INTEGRATION_FINAL_STATE.md`](INTEGRATION_FINAL_STATE.md) | V17 integration completion: AI configs, skill maps, code improvements across all 3 approaches |
| [`TEST_REPORT.md`](TEST_REPORT.md) | Auto-generated test results from `testAll.ps1` (33 tests across 3 approaches) |

---

## ğŸ”¨ buildAll.ps1 â€” What It Does

```
1. Extracts all 3 zips into folders
2. Patches B & D: moves a `using` statement from mid-file to top (cosmetic fix)
3. Runs `dotnet restore` + `dotnet build` for each approach
4. Reports build status with error highlighting
```

> **Note:** `testAll.ps1` applies an additional runtime fix: `Migrate()` â†’ `EnsureCreated()` in `Program.cs` because no EF migration files exist in the zips. The `buildAll.ps1` only handles compilation â€” the migration fix is only needed when actually running the containers.

Expected output:
```
=== TransactionWorkflow_ApproachA ===
Build succeeded.    0 Warning(s)    0 Error(s)
BUILD OK

=== TransactionWorkflow_ApproachB ===
Build succeeded.    0 Warning(s)    0 Error(s)
BUILD OK

=== TransactionWorkflow_ApproachD ===
Build succeeded.    0 Warning(s)    0 Error(s)
BUILD OK
```

---

## ğŸ§ª testAll.ps1 â€” Full Integration Test Suite (v2)

Runs Docker-based end-to-end tests against all 3 approaches sequentially. For each approach it extracts fresh from zip, applies automatic fixes, spins up containers, waits for the API, runs 11 tests, tears down, and moves to the next.

### Usage
```powershell
.\testAll.ps1
```

### Automatic Fixes Applied Before Testing

The script detects and patches known issues before building each approach:

| Fix | What | Why |
|-----|------|-----|
| `Migrate()` â†’ `EnsureCreated()` | Replaces EF migration call in `Program.cs` | No EF migration files exist â€” `EnsureCreated()` builds schema from model |
| Misplaced `using` | Moves `using TransactionWorkflow.API.Middleware;` to top of file (B, D) | Prevents compilation error |
| Entity-type routes | Uses `/admin/workflow/transaction/` for Approach B | B's multi-tenant admin routes are scoped by entity type |

### What It Tests

| # | Test | Category | Validates |
|---|------|----------|-----------|
| T1 | Create Transaction | Happy Path | `POST /transactions` returns ID + CREATED status |
| T2 | Get Transaction | Happy Path | `GET /transactions/{id}` returns correct status |
| T3 | Available Transitions | Happy Path | CREATED â†’ VALIDATED is listed |
| T4 | Full Workflow | Happy Path | CREATED â†’ VALIDATED â†’ PROCESSING â†’ COMPLETED |
| T5 | Transaction History | Happy Path | At least 3 history entries after full workflow |
| T6 | Bad Input â†’ 400 | Error Path | Negative amount + invalid currency rejected |
| T7 | Invalid Transition â†’ 400 | Error Path | CREATED â†’ COMPLETED skipped, returns 400 |
| T8 | Not Found â†’ 404 | Error Path | Non-existent transaction ID returns 404 |
| T9 | Workflow Visualization | Features | `GET /admin/workflow/visualize` returns Mermaid graph |
| T10 | Admin: Get Statuses | Features | At least 4 seeded statuses returned |
| T11 | Admin: Get Transitions | Features | At least 4 seeded transitions returned |

### Test Flow Per Approach
```
Extract zip â†’ Fix Migrate/using/routes â†’ docker-compose up â†’ Wait for API (90s max)
â†’ Run 11 API tests (with error body capture) â†’ docker-compose down â†’ Next approach
```

### Output
```
============================================================
  FINAL REPORT
============================================================

  Approach A (Vanilla)
  --------------------------------------------------
    [PASS] Docker Build
    [PASS] API Startup
    [PASS] Create Transaction
    ...

  Approach B (Multi-Tenant DNA)
  --------------------------------------------------
    [PASS] Docker Build
    ...

  Approach D (Strategic Hybrid)
  --------------------------------------------------
    [PASS] Docker Build
    ...

  TOTAL: 33 passed, 0 failed  |  Time: 8.2 min
============================================================
```

A `TEST_REPORT.md` is auto-generated with the full results table, fix log, and per-test detail column.

---

## ğŸ”¬ Deep Dive: How the Approaches Differ

The three approaches solve the same API contract but diverge fundamentally in how the **engine** and **database** work together.

### The Engine Signature â€” The Key Differentiator

**Approach A** â€” the engine knows it's dealing with a Transaction:
```csharp
public async Task TransitionAsync(Transaction transaction, string targetStatus)
{
    // Queries specific "TransactionTransitions" table
}
```

**Approach D** â€” the engine is generic in behavior but still single-tenant:
```csharp
public async Task<DataProcessResult<TransitionOutcome>> TryTransitionAsync(
    int currentStatusId, string targetStatus, int priorTransitionCount, ...)
{
    // Queries "WorkflowTransitions" table (single scope)
}
```

**Approach B** â€” the engine doesn't know what a "Transaction" is:
```csharp
public async Task<DataProcessResult<TransitionOutcome>> TryTransitionAsync(
    string entityType,           // â† THE KEY DIFFERENTIATOR
    string currentStatusName, int currentStatusId, string targetStatusName, ...)
{
    // Queries SHARED table filtered by EntityType
    var allowed = await _repo.GetAllowedTransitionsAsync(entityType, currentStatusId);
}
```

### Flow Comparison: Creating a Transaction

| Step | Approach A | Approach B | Why B differs |
|------|-----------|-----------|---------------|
| Service call | `_engine.GetInitialStatusAsync()` | `_engine.GetInitialStatusAsync("transaction")` | B needs the `entityType` to find the right workflow in shared tables |
| DB query | `WHERE IsInitial = 1` | `WHERE IsInitial = 1 AND EntityType = 'transaction'` | Same table holds initial states for Orders, Tickets, etc. |
| Result | `WorkflowStatus` | `WorkflowStatus` | Same output, different source scope |

### Flow Comparison: Executing a Transition

| Step | Approach A | Approach B | Architectural shift |
|------|-----------|-----------|-------------------|
| Adapter | `engine.TransitionAsync(txn, target)` | `engine.TryTransitionAsync("transaction", ...)` | B's `TransactionService` acts as an Adapter from specific â†’ generic |
| Isolation | Checks `FromId` / `ToId` | Checks `FromId` / `ToId` **AND** `EntityType` | B ensures a Transaction can't use an Order's transition rule |
| Extensibility | New entity = new engine + tables + service | New entity = **SQL INSERT only** | B achieves the Freedom Machine ideal |
| DB design | FK to `TransactionStatus` | FK to `WorkflowStatus` + composite index `(EntityType, Name)` | Uniqueness within scope, not globally |

### Summary of Tradeoffs

| Dimension | A (Vanilla) | B (Multi-Tenant) | D (Hybrid) |
|-----------|-------------|-------------------|------------|
| Complexity | Low | High (conceptually) | Medium |
| Flexibility | Low | **Maximum** | Medium (JSON rules) |
| State change cost | ğŸ”´ Code changes likely | ğŸŸ¢ **SQL only â€” always** | ğŸŸ¡ SQL for single type, code for multi |
| Code reuse | None | **Total** (shared engine) | High (patterns) |
| New entity cost | New engine + tables + service | **Zero code â€” SQL only** | New adapter + service |
| Tenant isolation | âŒ Not possible | âœ… `EntityType` composite key | âŒ Not possible |
| Dynamic transition rules | âŒ Not supported | âœ… JSON `Rules` column + evaluator | âœ… JSON `Rules` column + evaluator |
| `DataProcessResult` | âŒ Throws exceptions | âœ… Structured results + metadata | âœ… Structured results + metadata |
| Dynamic entity metadata | âŒ Fixed schema | âœ… `Metadata` JSON column | âœ… `Metadata` JSON column |
| Best for | Single microservice | Platform / monolith core | Enterprise microservice |

### The 4 Key Architectural Differences

These are the structural decisions that determine each approach's flexibility:

| Feature | A | D | B |
|---------|---|---|---|
| **EntityType scoping** | âŒ Global statuses | âŒ Global statuses | âœ… Per-entity-type |
| **Dynamic transition Rules** | âŒ None | âœ… `Dictionary<string,object>` | âœ… `Dictionary<string,object>` + evaluation |
| **DataProcessResult** | âŒ Throws exceptions | âœ… Yes | âœ… Yes + `WithMeta` chain |
| **Transaction Metadata** | âŒ Fixed schema | âœ… Dynamic dict | âœ… Dynamic dict |

B's `EntityType` field is the critical differentiator. It turns the state machine from a **single hardwired graph** into a **registry of unlimited graphs**, all managed via data. D is the pragmatic choice for a single-entity system that may grow; B is the correct choice if multi-entity or multi-tenant workflows are even remotely likely.

---

## ğŸ”® Extension Roadmap â€” From "Transaction Engine" to "Workflow Platform"

Each approach shipped here solves the assignment. The extensions below are **not implemented** â€” they are architectural suggestions showing how the V17 patterns would scale to real-world requirements. They demonstrate **why** the pattern choices matter: what costs one line in Approach B costs a full rebuild in Approach A.

> **Execution strategy:** The `agent.md` file contains ready-to-use AI prompts (for Copilot, Claude, Cursor) that implement each extension following V17 patterns. The `.ai-config/v17-skill-library.md` file serves as the "rule book" â€” upload it before any AI session to enforce correct patterns.

### The V17 Architecture Strategy

Before implementing, understand **why** each extension maps to a specific V17 skill:

| Extension | V17 Skill | Architectural Principle |
|-----------|-----------|----------------------|
| Configurable Tasks | Skill 05 (Database Fabric) | Don't add columns â€” use a JSON data column |
| Multi-Project Workflows | Skill 08 (Flow Definition) | Add a scope discriminator, not new tables |
| Role-Based Permissions | Skill 02 (Object Processor) | Permissions are JSON rules, not `if` statements |
| SSO / Flexible Auth | Skill 15 (API Gateway) | Auth config lives in `appsettings.json`, not in code |

### Extension 1: Configurable Tasks (JSON Data Columns)

**Problem:** Different departments want different fields â€” Sales needs "Priority", Finance needs "DueDate", Support needs "CustomerSegment". Adding columns for each is unsustainable.

**V17 Pattern:** Skill 05 (Database Fabric) â€” add a `Dictionary<string, object> Data` property stored as a JSON column via EF Core `ValueConversion`. No schema changes needed per field.

```csharp
// Example of how the API would look after implementing this extension:
POST /transactions
{ "amount": 500, "currency": "USD", "metadata": { "priority": "high", "department": "sales" } }
```

| Approach | Effort | How |
|----------|--------|-----|
| A | ğŸŸ¡ Medium | Add JSON column + ValueConverter to Transaction entity |
| B | âœ… Already done | `Metadata` dictionary already exists on Transaction |
| D | âœ… Already done | `Metadata` dictionary already exists on Transaction |

> **AI Prompt (from agent.md):** *"Add a `JsonDocument` property named `Data` to the Transaction entity. Configure EF Core `ValueConversion` to store as JSON string. Update the DTO to accept `Dictionary<string, object> Data`. Constraint: Do not add specific columns like 'DueDate' to the SQL table."*

### Extension 2: Multi-Project Workflows

**Problem:** Project A needs "ToDo â†’ Done" while Project B needs "Draft â†’ Review â†’ Publish". One workflow doesn't fit all.

**V17 Pattern:** Skill 08 (Flow Definition) â€” add a nullable `ProjectId` foreign key to `WorkflowStatus` and `WorkflowTransition`. Project-specific transitions override global defaults. The repository implements fallback logic: look for project-specific transitions first, fall back to global if none found.

```sql
-- Project-scoped workflow (no code changes in B)
INSERT INTO WorkflowStatuses (EntityType, Name, IsInitial, ProjectId)
VALUES ('task', 'DRAFT', 1, @projectBId);
```

| Approach | Effort | How |
|----------|--------|-----|
| A | ğŸ”´ High | New tables, new engine, new service â€” fundamental restructuring |
| B | ğŸŸ¢ Low | Add `ProjectId` column + repository fallback logic. `EntityType` scoping already provides the foundation |
| D | ğŸŸ¡ Medium | Add `ProjectId` + update repository queries + update engine interface |

> **AI Prompt (from agent.md):** *"Create a `Project` entity (Id, Name, Key). Update `WorkflowStatus` and `WorkflowTransition` to include nullable `ProjectId` FK. Update the repository: when loading transitions for Project X, look for specific transitions first; fallback to global if none found. Constraint: The WorkflowEngine interface must not change."*

### Extension 3: Role-Based Transition Permissions

**Problem:** Only managers should be able to approve transitions from "Validated" to "Processing". Currently anyone can.

**V17 Pattern:** Skill 02 (Object Processor) â€” permissions are **data, not code**. Store `{ "allowedRoles": ["Manager", "Admin"] }` in the transition's `Rules` JSON column. The generic `RuleEvaluator` checks it. The API Gateway (Skill 15) extracts user claims from the JWT token and passes them into the engine's `context` dictionary. The engine never imports auth libraries â€” it just reads keys from the context.

```json
// WorkflowTransitions.Rules column:
{ "allowedRoles": ["Manager", "Admin"], "maxRetries": 3 }
```

```csharp
// Controller extracts claims and passes to engine â€” engine stays auth-free:
var userRoles = HttpContext.User.Claims.Where(c => c.Type == ClaimTypes.Role).Select(c => c.Value).ToList();
var context = new Dictionary<string, object> { ["UserRoles"] = userRoles };
await _engine.TryTransitionAsync(statusId, target, context: context);
```

| Approach | Effort | How |
|----------|--------|-----|
| A | ğŸ”´ High | No rules engine â€” hardcode `if (role == "Admin")` in controller, doesn't scale |
| B | ğŸŸ¢ Low | Add `allowedRoles` key to `EvaluateTransitionRules` â€” ~10 lines of code |
| D | ğŸŸ¢ Low | Same as B â€” rules engine already exists in `EvaluateTransitionRules` |

> **AI Prompt (from agent.md):** *"Permissions are defined in the database by adding `{ 'allowedRoles': ['Manager', 'Admin'] }` to WorkflowTransition.Rules JSON. Extend `EvaluateTransitionRules` to check if the context dictionary contains a `UserRoles` list and validate against the rule. In the controller, extract roles from `HttpContext.User` claims and pass via context. Do NOT hardcode roles in C#."*

### Extension 4: SSO / Flexible Authentication

**Problem:** Customer A uses Azure AD, Customer B uses Okta, Customer C uses Google. Need to support all without code changes.

**V17 Pattern:** Skill 15 (API Gateway) â€” auth configuration lives in `appsettings.json`, not in code. A Strategy Pattern reads `Authority`, `ClientId`, `Audience` from config and wires up `JwtBearer` automatically.

```json
// appsettings.json â€” swap SSO provider with zero code:
"Auth": { "Authority": "https://login.microsoftonline.com/...", "ClientId": "...", "Audience": "..." }
```

**Key constraint:** The Domain project never depends on auth libraries. Authentication is purely an API/Infrastructure concern.

| Approach | Effort | How |
|----------|--------|-----|
| A | ğŸŸ¡ Medium | Add `AddFlexibleAuth()` extension in API project |
| B | ğŸŸ¡ Medium | Same â€” auth is orthogonal to the engine |
| D | ğŸŸ¡ Medium | Same â€” auth is orthogonal to the engine |

> **AI Prompt (from agent.md):** *"Implement a Strategy Pattern for auth in `Program.cs`. Create `AuthSettings` in `appsettings.json` with Authority, ClientId, Audience. Create an `AddFlexibleAuth(configuration)` extension that reads settings and configures JwtBearer. Constraint: The Domain project must NOT depend on any Auth libraries."*

### Extension Summary

| Extension | V17 Skill | A | B | D |
|-----------|-----------|---|---|---|
| Configurable tasks (JSON fields) | Skill 05 | ğŸŸ¡ Add column | âœ… Already built | âœ… Already built |
| Multi-project workflows | Skill 08 | ğŸ”´ Rebuild | ğŸŸ¢ Add scope column | ğŸŸ¡ Add scope + refactor |
| Role-based permissions | Skill 02 | ğŸ”´ Hardcode | ğŸŸ¢ Add JSON rule key | ğŸŸ¢ Add JSON rule key |
| SSO / flexible auth | Skill 15 | ğŸŸ¡ Config extension | ğŸŸ¡ Config extension | ğŸŸ¡ Config extension |

### How to Execute These Extensions

1. **Prepare:** Save the `.ai-config/v17-skill-library.md` file in your repo (already included).
2. **Context:** Start a new chat with Copilot/Claude/Cursor. Attach the library file + `CLAUDE.md`.
3. **Execute:** Paste the prompts from `agent.md` one by one:
   - Start with Extension 1 (Configurable Tasks) â€” updates the core entity
   - Move to Extension 2 (Multi-Project) â€” updates the schema and scoping
   - Implement Extension 3 (Permissions) â€” leverages the JSON rules
   - Finish with Extension 4 (SSO) â€” secures the API

> **Note:** Each extension builds on the previous. Extension 2 benefits from Extension 1's JSON column pattern. Extension 3 requires the `Rules` JSON column that B and D already have. Extension 4 is orthogonal and can be done at any point.

---

## ğŸ§  AI Agent Configuration

Each approach ships with pre-configured AI agent context files:

| Agent | Config File | Purpose |
|-------|-------------|---------|
| GitHub Copilot | `.github/copilot-instructions.md` | Inline suggestions following V17 patterns |
| Claude Code | `CLAUDE.md` | Project-aware coding with architecture rules |
| General / Any AI | `.ai-config/project-architecture.md` | Philosophy + pattern reference |
| Skill Library | `.ai-config/v17-skill-library.md` | V17 skill â†’ actual file mapping |
| Extension Prompts | `agent.md` | Copy-paste prompts for implementing Extensions 1â€“4 |

The `.ai-config/` folder contains prompt-engineered context so AI agents extend the project using the correct patterns (DataProcessResult, JSON rules, generic engines) instead of writing legacy code.

### Using the Skill Library with AI Agents

The `v17-skill-library.md` file acts as a rule book that enforces 5 core skills:

| Skill | Rule | AI Must... |
|-------|------|-----------|
| **Skill 01** (Core Interfaces) | All business logic returns `DataProcessResult<T>` | Never throw exceptions for logical failures |
| **Skill 02** (Object Processor) | Business rules are JSON configuration, not code | Use `RuleEvaluator` to parse `allowedRoles`, `minAmount`, `maxRetries` |
| **Skill 05** (Database Fabric) | Dynamic requirements use JSON columns | Never alter schema for new field requirements |
| **Skill 08** (Flow Definition) | Workflows are defined by data, not code | Scope by `ProjectId` or `EntityType`, not by new classes |
| **Skill 15** (API Gateway) | API layer translates, never contains logic | Extract claims from tokens â†’ inject into engine context |

**Workflow:** Upload `v17-skill-library.md` + `CLAUDE.md` at the start of any AI session â†’ paste prompts from `agent.md` â†’ AI follows the rules instead of writing legacy patterns.

---

## ğŸ‘” Why Three Approaches? â€” Architectural Decision-Making

> See [`cto_analysis.jsx`](cto_analysis.jsx) for an interactive dashboard with cost modeling, risk scenarios, and team fit analysis.

I deliberately built three implementations of the same assignment â€” not to pad the submission, but because **the hardest part of senior engineering isn't writing code, it's choosing the right architecture for the context.** Each approach represents a different answer to the same question: *"What happens 6 months after this deploys?"*

### The Recommendation

**For this assignment, I'm submitting Approach D.** It meets every requirement with a standard .NET stack that any evaluator expects to see. But underneath, it has a V17-inspired abstraction layer (DataProcessResult, JSON Rules, generic engine) that reveals how I actually think about systems â€” without triggering the "over-engineered" flag.

**If this were a production system with a growing roadmap, I'd build Approach B.** The `EntityType` discriminator is the kind of day-one decision that saves 6 months of refactoring when the PM says "now do Orders too." I've been on teams that paid the cost of not making that decision upfront.

**Approach A exists to show I know when NOT to over-engineer.** Sometimes the right answer is the simplest one that meets the requirements. The judgment is in knowing which situation you're in.

### Tradeoff Analysis â€” How I'd Reason Through This as a Tech Lead

| Decision Factor | A (Vanilla) | B (Platform) | D (Hybrid) |
|----------------|-------------|--------------|------------|
| **Initial delivery speed** | ğŸŸ¢ Fastest (4â€“5h) | ğŸ”´ Slowest (5â€“7h) | ğŸŸ¡ Middle (6â€“8h) |
| **PM says "add Orders next quarter"** | ğŸ”´ Full feature build (weeks) | ğŸŸ¢ SQL INSERT (minutes) | ğŸŸ¡ Refactor into B (days) |
| **Different workflow per client/tenant** | ğŸ”´ Not possible | ğŸŸ¢ Composite EntityType key | ğŸ”´ Not possible |
| **New dev onboarding time** | ğŸŸ¢ 1â€“2 days | ğŸŸ¡ 3â€“5 days (needs DNA concepts) | ğŸŸ¢ 2â€“3 days |
| **Tech debt at 12 months** | ğŸ”´ High â€” patterns diverge per entity | ğŸŸ¢ Low â€” shared engine | ğŸŸ¡ Medium â€” single scope limits |
| **Probability of major refactor** | ğŸ”´ ~90% when scope grows | ğŸŸ¢ ~10% already generic | ğŸŸ¡ ~50% when 2nd entity arrives |

### The Cost Curve That Drives the Decision

The critical insight is that **the cost curves cross.** A is cheapest at month 1 but most expensive by month 12. B is most expensive at month 1 but cheapest once scope expands. D sits in between â€” a hedge that delays the B decision without the A penalty.

If your product roadmap has exactly one workflow type forever â†’ ship **D**. If "add Orders/Tickets/Refunds" is on any roadmap within 18 months â†’ ship **B** now. Migrating Dâ†’B later costs 3â€“5Ã— more than building B from the start, because you're retrofitting the `EntityType` discriminator into a live schema with production data.

### Risk Scenarios I Designed For

| What Could Go Wrong | A | B | D |
|---------------------|---|---|---|
| Scope creep â€” new entity types needed | ğŸ”´ Each is a project | ğŸŸ¢ Each is a SQL script | ğŸŸ¡ Refactor required |
| Junior dev introduces EF tracking bug | ğŸ”´ Exception swallowed in middleware | ğŸŸ¢ DataProcessResult surfaces errors explicitly | ğŸŸ¢ Same â€” structured results |
| Security audit flags open admin endpoints | ğŸŸ¢ V2: Resolved (API Key + AdminOnly) | ğŸŸ¢ V2: Resolved | ğŸŸ¢ V2: Resolved |
| Need to swap database or add second provider | ğŸ”´ EF tightly coupled | ğŸŸ¢ Generic interfaces abstract storage | ğŸŸ¡ Interfaces exist but single impl |
| Production incident â€” unhandled exception | ğŸŸ¢ V2: Environment-aware middleware | ğŸŸ¢ V2: Same | ğŸŸ¢ V2: Same |

### Which Team Ships Which Approach Best

This is the part most assignments don't address â€” architecture isn't just about code, it's about the team maintaining it:

| Team Shape | Best Fit | Why |
|------------|----------|-----|
| 3 juniors + 1 senior | A | Standard patterns, everyone contributes from day 1. Low coordination cost. |
| 2 mid-level + 1 staff/lead | D | Lead designs the abstraction layer, mid-levels implement within its guardrails. DataProcessResult and JSON Rules are learnable patterns. |
| Full senior / platform team | B | Everyone understands EntityType scoping. Enables parallel work â€” one dev adds Orders, another adds Tickets, no merge conflicts on the engine. |
| Solo developer / startup | D â†’ B | Start D to ship fast. Migrate to B when the second entity type arrives. The upgrade path is documented and the patterns are compatible. |

### The EF Tracking Bug â€” Systematic Debugging in Practice

During integration testing, I hit a real production-class bug: 7 test failures across all 3 approaches traced to 2 root causes (EF entity tracking conflict + middleware error swallowing) in under 30 minutes. Rather than just fixing it, I documented the full investigation methodology in [`BugInvestigation_SKILL.md`](BugInvestigation_SKILL.md) â€” covering the DI Lifetime Ã— Caching matrix, the three manifestations of tracking conflicts, and a decision tree for diagnosing 500 errors. This is how I approach debugging: systematically, reproducibly, and with documentation that prevents the same class of bug from recurring.

### Discussion Points â€” Questions I'm Ready For

1. **"Why didn't you just submit B?"** â€” B is the right architecture for a platform, but this assignment describes a microservice. D matches the context. I documented B to show I know it exists and when to reach for it.

2. **"What breaks first at 10Ã— volume?"** â€” Cache invalidation under concurrent transitions. The `IMemoryCache` is singleton, `DbContext` is scoped â€” at high volume the tracking conflict window grows. Next step: Redis with pub/sub invalidation, RowVersion-based optimistic concurrency.

3. **"Walk me through the EF tracking bug."** â€” 7 test failures across 3 approaches, 2 root causes, diagnosed in under 30 minutes. Full methodology documented in [`BugInvestigation_SKILL.md`](BugInvestigation_SKILL.md) â€” systematic, reproducible, not trial-and-error.

4. **"How would you migrate D to B in production?"** â€” Add `EntityType` column with default `'transaction'` (existing data auto-migrates). Dual-write period. Backfill. Swap engine to B's generic signature. Drop default constraint. Zero downtime, fully reversible at each step.
